-- ===== [[ Variables and Stuff ]] ===== --

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
WindUI:SetNotificationLower(true)

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local rs = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Lighting = game:GetService("Lighting")
local effect = Lighting:FindFirstChild("VibrantEffect")
local vibrantEffect = Lighting:FindFirstChild("VibrantEffect")
local RunService = game:GetService("RunService")

Lighting.ClockTime = 14
Lighting.GlobalShadows = false

local VirtualUser = game:GetService("VirtualUser")

local scan_map = false

local killAuraToggle = false
local chopAuraToggle = false
local auraRadius = 100
local currentammount = 0

local toolsDamageIDs = {
    ["Old Axe"] = "3_7367831688",
    ["Good Axe"] = "112_7367831688",
    ["Strong Axe"] = "116_7367831688",
    ["Ice Axe"] = "116_7367831688",
    ["Admin Axe"] = "116_7367831688",
    ["Morningstar"] = "116_7367831688",
    ["Laser Sword"] = "116_7367831688",
    ["Ice Sword"] = "116_7367831688",
    ["Infernal Sword"] = "6_7461591369",
    ["Katana"] = "116_7367831688",
    ["Trident"] = "116_7367831688",
    ["Poison Spear"] = "116_7367831688",
    ["Chainsaw"] = "647_8992824875",
    ["Spear"] = "196_8999010016",
    ["Rifle"] = "22_6180169035"
}


local autoFeedToggle = false
local selectedFood = {}
local hungerThreshold = 75
local alwaysFeedEnabledItems = {}
local alimentos = {
    "Apple",
    "Berry",
    "Carrot",
    "Cake",
    "Chili",
	"Cooked Clownfish",
	"Cooked Swordfish",
	"Cooked Jellyfish",
	"Cooked Char",
	"Cooked Eel",
	"Cooked Shark",
    "Cooked Ribs",
    "Cooked Mackerel",
    "Cooked Salmon",
    "Cooked Morsel",
    "Cooked Steak"
}


local ie = {
    "Bandage", "Bolt", "Broken Fan", "Broken Microwave", "Cake", "Apple", "Carrot", "Chair", "Coal", "Coin Stack",
    "Cooked Morsel", "Cooked Steak", "Fuel Canister", "Iron Body", "Leather Body", "Obsidiron Body", "Log", "MadKit", "Metal Chair",
    "MedKit", "Old Car Engine", "Old Flashlight", "Old Radio", "Revolver", "Revolver Ammo", "Rifle", "Rifle Ammo",
    "Morsel", "Sheet Metal", "Steak", "Tyre", "Washing Machine", "Cultist Gem", "Cultist Staff", "Gem of the Forest Fragment", "Frozen Shuriken",
	"Tactical Shotgun", "Snowball", "Kunai", "Infernal Sword", "Infernal Sack", "Infernal Crossbow", "Crossbow", "Good Axe", "Good Sack",
}
local me = {"Bunny", "Wolf", "Alpha Wolf", "Bear", "Crossbow Cultist", "Alien", "Alien Elite", "Polar Bear", "Arctic Fox", "Meteor Crab", "Mammoth", "Cultist", "Cultist Melee", "Cultist Crossbow", "Cultist Juggernaut"}

local craftableItems = {
    "Map", "Old Bed", "Bunny Trap", "Sun Dial",
    "Regular Bed", "Compass", "Freezer", "Farm Plot", "Wood Rain Storage",
    "Shelf", "Log Wall", "Bear Trap", "Crock Pot", "Good Bed", "Radar",
    "Boost Pad", "Biofuel Processor", "Lighting Rod", "Torch", "Ammo Crate",
    "Giant Bed", "Oil Dril", "Teleporter", "Respawn Capsule",
    "Temporal Accelerometer", "Weather Machine"
}

local selectedCraftItems = {}

local craftingBenchItems = {
    "Crafting Bench 1",
    "Crafting Bench 2",
    "Crafting Bench 3",
    "Crafting Bench 4",
    "Crafting Bench 5"
}

local selectedBenchItems = {}

local isCollecting = false
local originalPosition = nil
local autoBringEnabled = false

local BlueprintToggleEnabled = false
local PeltsToggleEnabled = false
local junkToggleEnabled = false
local fuelToggleEnabled = false
local foodToggleEnabled = false
local medicalToggleEnabled = false
local cultistToggleEnabled = false
local equipmentToggleEnabled = false

local BlueprintLoopRunning = false
local PeltsLoopRunning = false
local junkLoopRunning = false
local fuelLoopRunning = false
local foodLoopRunning = false
local medicalLoopRunning = false
local cultistLoopRunning = false
local equipmentLoopRunning = false

local function bypassBringSystem(items, stopFlag)
    if isCollecting then 
        return 
    end
    
    isCollecting = true
    local player = game.Players.LocalPlayer
    
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then 
        isCollecting = false
        return 
    end
    
    local hrp = player.Character.HumanoidRootPart
    originalPosition = hrp.CFrame
    
    for _, itemName in ipairs(items) do
        if stopFlag and not stopFlag() then
            break
        end
        
        local itemsFound = {}
    
        for _, item in ipairs(workspace:GetDescendants()) do
            if item.Name == itemName and (item:IsA("BasePart") or item:IsA("Model")) then
                local itemPart = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")) or item
                if itemPart and itemPart.Parent ~= player.Character then
                    table.insert(itemsFound, {item = item, part = itemPart})
                end
            end
        end
    
        for _, itemData in ipairs(itemsFound) do
            if stopFlag and not stopFlag() then
                break
            end
            
            local item = itemData.item
            local itemPart = itemData.part
            
            if itemPart and itemPart.Parent then
                local itemPos = itemPart.CFrame + Vector3.new(0, 5, 0)
                hrp.CFrame = itemPos
                
                local playerPos = hrp.Position + Vector3.new(0, -1, 0)
                pcall(function()
                    itemPart.CFrame = CFrame.new(playerPos)
                    itemPart.Velocity = Vector3.new(0, 0, 0)
                    itemPart.AngularVelocity = Vector3.new(0, 0, 0)
                end)
                
                hrp.CFrame = originalPosition
            
                pcall(function()
                    local landingPos = originalPosition.Position + Vector3.new(
                        math.random(-4, 4), 
                        2, 
                        math.random(-4, 4)
                    )
                    itemPart.CFrame = CFrame.new(landingPos)
                    itemPart.Velocity = Vector3.new(0, 0, 0)
                    itemPart.AngularVelocity = Vector3.new(0, 0, 0)
                end)
            end
            
            wait(0.1) 
        end
    end

    if originalPosition then
        hrp.CFrame = originalPosition
    end
    
    isCollecting = false
end

local campfireFuelItems = {"Log", "Coal", "Chair", "Fuel Canister", "Oil Barrel", "Biofuel"}
local campfireDropPos = Vector3.new(0, 19, 0)
local selectedCampfireItem = nil
local autoUpgradeCampfireEnabled = false

local scrapjunkItems = {"Log", "Chair", "Tyre", "Bolt", "Broken Fan", "Broken Microwave", "Sheet Metal", "Old Radio", "Washing Machine", "Old Car Engine", "Cultist Gem", "Gem of the Forest Fragment"}
local autoScrapPos = Vector3.new(21, 20, -5)
local selectedScrapItem = nil
local autoScrapItemsEnabled = false

local autocookItems = {"Morsel", "Steak", "Ribs", "Salmon", "Mackerel"}
local autoCookEnabledItems = {}
local autoCookEnabled = false

local function getAnyToolWithDamageID(isChopAura)
    for toolName, damageID in pairs(toolsDamageIDs) do
        if isChopAura and toolName ~= "Old Axe" and toolName ~= "Good Axe" and toolName ~= "Strong Axe" and toolName ~= "Ice Axe" and toolName ~= "Chainsaw" then
            continue
        end
        local tool = LocalPlayer:FindFirstChild("Inventory") and LocalPlayer.Inventory:FindFirstChild(toolName)
        if tool then
            return tool, damageID
        end
    end
    return nil, nil
end

local function equipTool(tool)
    if tool then
        ReplicatedStorage:WaitForChild("RemoteEvents").EquipItemHandle:FireServer("FireAllClients", tool)
    end
end

local function unequipTool(tool)
    if tool then
        ReplicatedStorage:WaitForChild("RemoteEvents").UnequipItemHandle:FireServer("FireAllClients", tool)
    end
end

local function killAuraLoop()
    while killAuraToggle do
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local tool, damageID = getAnyToolWithDamageID(false)
            if tool and damageID then
                equipTool(tool)
                for _, mob in ipairs(Workspace.Characters:GetChildren()) do
                    if mob:IsA("Model") then
                        local part = mob:FindFirstChildWhichIsA("BasePart")
                        if part and (part.Position - hrp.Position).Magnitude <= auraRadius then
                            pcall(function()
                                ReplicatedStorage:WaitForChild("RemoteEvents").ToolDamageObject:InvokeServer(
                                    mob,
                                    tool,
                                    damageID,
                                    CFrame.new(part.Position)
                                )
                            end)
                        end
                    end
                end
                task.wait(0.01)
            else
                task.wait(0.1)
            end
        else
            task.wait(0.5)
        end
    end
end

local AutoPlantToggle = false

local function autoplant()
    while AutoPlantToggle do
        local args = {
            Instance.new("Model"),
            Vector3.new(-41.2053, 1.0633, 29.2236)
        }
        game:GetService("ReplicatedStorage")
            :WaitForChild("RemoteEvents")
            :WaitForChild("RequestPlantItem")
            :InvokeServer(unpack(args))
        task.wait(1)
    end
end

local function chopAuraLoop()
    while chopAuraToggle do
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local tool, baseDamageID = getAnyToolWithDamageID(true)
            if tool and baseDamageID then
                equipTool(tool)
                currentammount = currentammount + 1
                local trees = {}
                local map = Workspace:FindFirstChild("Map")
                if map then
                    if map:FindFirstChild("Foliage") then
                        for _, obj in ipairs(map.Foliage:GetChildren()) do
                            if obj:IsA("Model") and (obj.Name == "Small Tree" or obj.Name == "Snowy Small Tree") then
                                table.insert(trees, obj)
                            end
                        end
                    end
                    if map:FindFirstChild("Landmarks") then
                        for _, obj in ipairs(map.Landmarks:GetChildren()) do
                            if obj:IsA("Model") and obj.Name == "Small Tree" then
                                table.insert(trees, obj)
                            end
                        end
                    end
                end
                for _, tree in ipairs(trees) do
                    local trunk = tree:FindFirstChild("Trunk")
                    if trunk and trunk:IsA("BasePart") and (trunk.Position - hrp.Position).Magnitude <= auraRadius then
                        local alreadyammount = false
                        task.spawn(function()
                            while chopAuraToggle and tree and tree.Parent and not alreadyammount do
                                alreadyammount = true
                                currentammount = currentammount + 1
                                pcall(function()
                                    ReplicatedStorage:WaitForChild("RemoteEvents").ToolDamageObject:InvokeServer(
                                        tree,
                                        tool,
                                        tostring(currentammount) .. "_7367831688",
                                        CFrame.new(-2.962610244751, 4.5547881126404, -75.950843811035, 0.89621275663376, -1.3894891459643e-08, 0.44362446665764, -7.994568895775e-10, 1, 3.293635941759e-08, -0.44362446665764, -2.9872644802253e-08, 0.89621275663376)
                                    )
                                end)
                            end
                        end)
                    end
                end
                task.wait(0.1)
            else
                task.wait(1)
            end
        else
            task.wait(0.5)
        end
    end
end

function wiki(nome)
    local c = 0
    for _, i in ipairs(Workspace.Items:GetChildren()) do
        if i.Name == nome then
            c = c + 1
        end
    end
    return c
end

function ghn()
    return math.floor(LocalPlayer.PlayerGui.Interface.StatBars.HungerBar.Bar.Size.X.Scale * 100)
end

function feed(nome)
    for _, item in ipairs(Workspace.Items:GetChildren()) do
        if item.Name == nome then
            ReplicatedStorage.RemoteEvents.RequestConsumeItem:InvokeServer(item)
            break
        end
    end
end

function notifeed(nome)
    WindUI:Notify({
        Title = "Auto Food Paused",
        Content = "The food is gone",
        Duration = 3
    })
end

local function moveItemToPos(item, position)
    if not item or not item:IsDescendantOf(workspace) or not item:IsA("BasePart") and not item:IsA("Model") then return end
    local part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")) or item
    if not part or not part:IsA("BasePart") then return end

    if item:IsA("Model") and not item.PrimaryPart then
        pcall(function() item.PrimaryPart = part end)
    end

    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents").RequestStartDraggingItem:FireServer(item)
        if item:IsA("Model") then
            item:SetPrimaryPartCFrame(CFrame.new(position))
        else
            part.CFrame = CFrame.new(position)
        end
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents").StopDraggingItem:FireServer(item)
    end)
end

local function getChests()
    local chests = {}
    local chestNames = {}
    local seenPositions = {}
    local index = 1

    for _, item in ipairs(workspace:WaitForChild("Items"):GetChildren()) do
        if item.Name:match("^Item Chest") and not item:GetAttribute("8721081708ed") then
            local part = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")
            if part then
                local pos = tostring(part.Position)
                if not seenPositions[pos] then
                    seenPositions[pos] = true
                    table.insert(chests, item)
                    table.insert(chestNames, "Chest " .. index)
                    index = index + 1
                end
            end
        end
    end

    return chests, chestNames
end

local currentChests, currentChestNames = getChests()
local selectedChest = currentChestNames[1] or nil

local function getMobs()
    local mobs = {}
    local mobNames = {}
    local index = 1
    for _, character in ipairs(workspace:WaitForChild("Characters"):GetChildren()) do
        if character.Name:match("^Lost Child") and character:GetAttribute("Lost") == true then
            table.insert(mobs, character)
            table.insert(mobNames, character.Name)
            index = index + 1
        end
    end
    return mobs, mobNames
end

local currentMobs, currentMobNames = getMobs()
local selectedMob = currentMobNames[1] or nil

function tp1()
	(game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart").CFrame =
CFrame.new(0.43132782, 15.77634621, -1.88620758, -0.270917892, 0.102997094, 0.957076371, 0.639657021, 0.762253821, 0.0990355015, -0.719334781, 0.639031112, -0.272391081)
end

local function tp2()
    local targetPart = workspace:FindFirstChild("Map")
        and workspace.Map:FindFirstChild("Landmarks")
        and workspace.Map.Landmarks:FindFirstChild("Stronghold")
        and workspace.Map.Landmarks.Stronghold:FindFirstChild("Functional")
        and workspace.Map.Landmarks.Stronghold.Functional:FindFirstChild("EntryDoors")
        and workspace.Map.Landmarks.Stronghold.Functional.EntryDoors:FindFirstChild("DoorRight")
        and workspace.Map.Landmarks.Stronghold.Functional.EntryDoors.DoorRight:FindFirstChild("Model")
    if targetPart then
        local children = targetPart:GetChildren()
        local destination = children[5]
        if destination and destination:IsA("BasePart") then
            local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.CFrame = destination.CFrame + Vector3.new(0, 5, 0)
            end
        end
    end
end

local flyToggle = false
local flySpeed = 1
local FLYING = false
local flyKeyDown, flyKeyUp, mfly1, mfly2
local IYMouse = game:GetService("UserInputService")

local function sFLY()
    repeat task.wait() until Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart") and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    repeat task.wait() until IYMouse
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect(); flyKeyUp:Disconnect() end

    local T = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = flySpeed

    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro')
        local BV = Instance.new('BodyVelocity')
        BG.P = 9e4
        BG.Parent = T
        BV.Parent = T
        BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.CFrame = T.CFrame
        BV.Velocity = Vector3.new(0, 0, 0)
        BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            while FLYING do
                task.wait()
                if not flyToggle and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                    Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = flySpeed
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.Velocity = Vector3.new(0, 0, 0)
                end
                BG.CFrame = workspace.CurrentCamera.CoordinateFrame
            end
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:Destroy()
            BV:Destroy()
            if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
            end
        end)
    end
    flyKeyDown = IYMouse.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local KEY = input.KeyCode.Name
            if KEY == "W" then
                CONTROL.F = flySpeed
            elseif KEY == "S" then
                CONTROL.B = -flySpeed
            elseif KEY == "A" then
                CONTROL.L = -flySpeed
            elseif KEY == "D" then 
                CONTROL.R = flySpeed
            elseif KEY == "E" then
                CONTROL.Q = flySpeed * 2
            elseif KEY == "Q" then
                CONTROL.E = -flySpeed * 2
            end
            pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
        end
    end)
    flyKeyUp = IYMouse.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local KEY = input.KeyCode.Name
            if KEY == "W" then
                CONTROL.F = 0
            elseif KEY == "S" then
                CONTROL.B = 0
            elseif KEY == "A" then
                CONTROL.L = 0
            elseif KEY == "D" then
                CONTROL.R = 0
            elseif KEY == "E" then
                CONTROL.Q = 0
            elseif KEY == "Q" then
                CONTROL.E = 0
            end
        end
    end)
    FLY()
end

local function NOFLY()
    FLYING = false
    if flyKeyDown then flyKeyDown:Disconnect() end
    if flyKeyUp then flyKeyUp:Disconnect() end
    if mfly1 then mfly1:Disconnect() end
    if mfly2 then mfly2:Disconnect() end
    if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
        Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
    end
    pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

local function UnMobileFly()
    pcall(function()
        FLYING = false
        local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        if root:FindFirstChild("BodyVelocity") then root:FindFirstChild("BodyVelocity"):Destroy() end
        if root:FindFirstChild("BodyGyro") then root:FindFirstChild("BodyGyro"):Destroy() end
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") then
            Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
        end
        if mfly1 then mfly1:Disconnect() end
        if mfly2 then mfly2:Disconnect() end
    end)
end

local function MobileFly()
    UnMobileFly()
    FLYING = true

    local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local camera = workspace.CurrentCamera
    local v3none = Vector3.new()
    local v3zero = Vector3.new(0, 0, 0)
    local v3inf = Vector3.new(9e9, 9e9, 9e9)

    local controlModule = require(Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    local bv = Instance.new("BodyVelocity")
    bv.Name = "BodyVelocity"
    bv.Parent = root
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = "BodyGyro"
    bg.Parent = root
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50

    mfly1 = Players.LocalPlayer.CharacterAdded:Connect(function()
        local newRoot = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        local newBv = Instance.new("BodyVelocity")
        newBv.Name = "BodyVelocity"
        newBv.Parent = newRoot
        newBv.MaxForce = v3zero
        newBv.Velocity = v3zero

        local newBg = Instance.new("BodyGyro")
        newBg.Name = "BodyGyro"
        newBg.Parent = newRoot
        newBg.MaxTorque = v3inf
        newBg.P = 1000
        newBg.D = 50
    end)

    mfly2 = game:GetService("RunService").RenderStepped:Connect(function()
        root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        camera = workspace.CurrentCamera
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild("BodyVelocity") and root:FindFirstChild("BodyGyro") then
            local humanoid = Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
            local VelocityHandler = root:FindFirstChild("BodyVelocity")
            local GyroHandler = root:FindFirstChild("BodyGyro")

            VelocityHandler.MaxForce = v3inf
            GyroHandler.MaxTorque = v3inf
            humanoid.PlatformStand = true
            GyroHandler.CFrame = camera.CoordinateFrame
            VelocityHandler.Velocity = v3none

            local direction = controlModule:GetMoveVector()
            if direction.X > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * (flySpeed * 50))
            end
            if direction.X < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * (flySpeed * 50))
            end
            if direction.Z > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * (flySpeed * 50))
            end
            if direction.Z < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * (flySpeed * 50))
            end
        end
    end)
end

local workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local function bringItemsByPlayerTP(itemNames, originalPosition)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then 
        return 
    end
    
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local itemsFound = {}
    
    for _, itemName in ipairs(itemNames) do
        for _, item in ipairs(workspace:GetDescendants()) do
            if item.Name == itemName and (item:IsA("BasePart") or item:IsA("Model")) then
                local part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")) or item
                if part and part:IsA("BasePart") then
                    table.insert(itemsFound, {item = item, part = part})
                end
            end
        end
    end
    
    for i, itemData in ipairs(itemsFound) do
        local item = itemData.item
        local part = itemData.part
        
        if item and item.Parent and part then
            local itemPosition = part.Position + Vector3.new(0, 3, 0)
            hrp.CFrame = CFrame.new(itemPosition)
            
            task.wait(0.2)
            
            pcall(function()
                ReplicatedStorage:WaitForChild("RemoteEvents").RequestStartDraggingItem:FireServer(item)
            end)
            
            task.wait(0.3)
            
            hrp.CFrame = CFrame.new(originalPosition)
            
            task.wait(0.2)
            
            pcall(function()
                ReplicatedStorage:WaitForChild("RemoteEvents").StopDraggingItem:FireServer(item)
            end)
            
            task.wait(0.5)
        end
    end
    
    hrp.CFrame = CFrame.new(originalPosition)
end

_G.playerBillboards = {}
_G.EspPlayerOn = false
_G.EspSize = 18

function createPlayerNameBillboard(player)
    if not player or not player.Character then
        return nil
    end
    
    local character = player.Character
    local head = character:FindFirstChild("Head")
    
    if not head then
        return nil
    end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "PlayerNameBillboard"
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.Parent = head
    
    local label = Instance.new("TextLabel")
    label.Name = "NameLabel"
    label.Size = UDim2.new(1, 0, 1, 0)  
    label.BackgroundTransparency = 1
    label.Text = player.Name
    label.TextColor3 = Color3.new(1, 1, 1) 
    label.TextSize = _G.EspSize  
    label.TextScaled = false  
    label.Font = Enum.Font.Code
    label.Parent = billboard
    
    _G.playerBillboards[player.Name] = billboard
    
    return billboard
end

for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    if player ~= game:GetService("Players").LocalPlayer then
        createPlayerNameBillboard(player)
    end
end

game:GetService("Players").PlayerAdded:Connect(function(player)
    if player ~= game:GetService("Players").LocalPlayer then
        player.CharacterAdded:Connect(function()
            createPlayerNameBillboard(player)
        end)
    end
end)

local Stats = game:GetService("Stats")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

_G.AutoPlantCenter = Vector3.new(-0, 1.5, -0)
_G.AutoSapRadius = 50
_G.Sapling = 150
_G.AutoPlantEnabled = false

function StartAutoPlant()
    _G.AutoPlantEnabled = true
    spawn(function() 
        while _G.AutoPlantEnabled do
            local selectedSapling = nil
            for _, item in pairs(workspace.Items:GetDescendants()) do
                if item:IsA("BasePart") or item:IsA("Model") then
                    if string.find(string.lower(item.Name), "sapling") or 
                       string.find(string.lower(item.Name), "seed") or
                       string.find(string.lower(item.Name), "plant") then
                        selectedSapling = item
                        break
                    end
                end
            end
            
            if not selectedSapling then
                for _, item in pairs(workspace.Items:GetDescendants()) do
                    if item:IsA("BasePart") or item:IsA("Model") then
                        selectedSapling = item
                        break
                    end
                end
            end
            
            if selectedSapling then
                for i = 1, _G.Sapling do
                    if not _G.AutoPlantEnabled then break end
                
                    local angle = ((i - 1) / _G.Sapling) * 2 * math.pi
                    local circlePosition = _G.AutoPlantCenter + Vector3.new(
                        math.cos(angle) * _G.AutoSapRadius,
                        0,
                        math.sin(angle) * _G.AutoSapRadius
                    )
                    
                    pcall(function()
                        if selectedSapling:IsA("BasePart") then
                            selectedSapling.CanCollide = false
                            selectedSapling.CFrame = CFrame.new(circlePosition)
                            selectedSapling.Anchored = true
                        elseif selectedSapling:IsA("Model") then
                            for _, part in pairs(selectedSapling:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    part.CanCollide = false
                                    part.Anchored = true
                                end
                            end
                            
                            if selectedSapling.PrimaryPart then
                                selectedSapling:SetPrimaryPartCFrame(CFrame.new(circlePosition))
                            else
                                local part = selectedSapling:FindFirstChildWhichIsA("BasePart")
                                if part then
                                    part.CFrame = CFrame.new(circlePosition)
                                end
                            end
                        end
                    end)
            
                    local args = {
                        selectedSapling,
                        vector.create(circlePosition.X, circlePosition.Y, circlePosition.Z)
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("RequestPlantItem"):InvokeServer(unpack(args))
                    end)
                    
                    wait(0.15)
                end
                
                wait(2)
            else
                WindUI:Notify({
                    Title = "AutoPlant",
                    Icon = "bell-ring",
                    Content = "No More Sapling Found",
                    Duration = 3,
                })
                wait(2)
            end
        end
    end) 
end

function StopAutoPlant()
    _G.AutoPlantEnabled = false
end

local MobsFolder = workspace.Characters
local ToolDamageEvent = game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("ToolDamageObject")

local MobsList = {"Cultist", "Crossbow Cultist", "Cultist Juggernaut", "Bunny", "Wolf", "Alpha Wolf", "Bear", "Snow Bear", "Meteor Crab", "Deer", "Owl", "Ram"}
local SelectedMobs = {}
local HitBoxSize = 50
local HitboxesActive = false

local function OnHitConnect(hit, mobModel)
    if hit and hit.Parent then
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            ToolDamageEvent:FireServer(mobModel) 
        end
    end
end

local function CreateHitboxForMob(mob)
    local primary = mob:FindFirstChild("HumanoidRootPart") or mob.PrimaryPart
    if not primary then return end
    
    local old = mob:FindFirstChild("HitBoxForMob")
    if old then
        old:Destroy()
    end
    
    local hitbox = Instance.new("Part")
    hitbox.Name = "HitBoxForMob"
    hitbox.Size = Vector3.new(HitBoxSize, HitBoxSize, HitBoxSize)
    hitbox.Shape = Enum.PartType.Ball
    hitbox.Color = Color3.fromRGB(138, 43, 226)
    hitbox.Transparency = 1
    hitbox.CanCollide = false
    hitbox.Anchored = false
    hitbox.Massless = true
    hitbox.CFrame = primary.CFrame
    hitbox.Parent = mob

    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hitbox
    weld.Part1 = primary
    weld.Parent = hitbox

    hitbox.Touched:Connect(function(hit)
        OnHitConnect(hit, mob)
    end)
end

local function RemoveHitboxFromMob(mob)
    local hitbox = mob:FindFirstChild("HitBoxForMob")
    if hitbox then
        hitbox:Destroy()
    end
end

local function UpdateHitboxes()
    if not HitboxesActive then return end
    
    for _, mob in ipairs(MobsFolder:GetChildren()) do
        if mob:IsA("Model") then
            local shouldHaveHitbox = table.find(SelectedMobs, mob.Name)
            local hasHitbox = mob:FindFirstChild("HitBoxForMob")
            
            if shouldHaveHitbox and not hasHitbox then
                CreateHitboxForMob(mob)
            elseif not shouldHaveHitbox and hasHitbox then
                RemoveHitboxFromMob(mob)
            elseif shouldHaveHitbox and hasHitbox then
                local hitbox = mob:FindFirstChild("HitBoxForMob")
                if hitbox and hitbox.Size.X ~= HitBoxSize then
                    hitbox.Size = Vector3.new(HitBoxSize, HitBoxSize, HitBoxSize)
                end
            end
        end
    end
end

local function AddAllHitboxes()
    HitboxesActive = true
    for _, mob in ipairs(MobsFolder:GetChildren()) do
        if mob:IsA("Model") and table.find(SelectedMobs, mob.Name) then
            CreateHitboxForMob(mob)
        end
    end
end

local function RemoveAllHitboxes()
    HitboxesActive = false
    for _, mob in ipairs(MobsFolder:GetChildren()) do
        if mob:IsA("Model") then
            RemoveHitboxFromMob(mob)
        end
    end
end

MobsFolder.ChildAdded:Connect(function(child)
    if HitboxesActive and child:IsA("Model") and table.find(SelectedMobs, child.Name) then
        wait(0.1)
        CreateHitboxForMob(child)
    end
end)

local TreeFold = workspace.Map.Landmarks
local TreeTypes = {"Tree Small"} 
local SelectedTrees = {}
local TreeHitBoxSize = 30
local TreeHitboxesActive = false

local function OnTreeHitConnect(hit, treeModel)
    if hit and hit.Parent then
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            ToolDamageEvent:FireServer(treeModel) 
        end
    end
end

local function CreateHitboxForTree(tree)
    local primary = tree:FindFirstChild("Trunk") or tree.PrimaryPart or tree:FindFirstChildOfClass("Part")
    if not primary then return end
    
    local old = tree:FindFirstChild("HitBoxForTree")
    if old then
        old:Destroy()
    end
    
    local hitbox = Instance.new("Part")
    hitbox.Name = "HitBoxForTree"
    hitbox.Size = Vector3.new(TreeHitBoxSize, TreeHitBoxSize, TreeHitBoxSize)
    hitbox.Shape = Enum.PartType.Ball
    hitbox.Color = Color3.fromRGB(34, 139, 34)
    hitbox.Transparency = 0.6
    hitbox.CanCollide = false
    hitbox.Anchored = false
    hitbox.Massless = true
    hitbox.CFrame = primary.CFrame
    hitbox.Parent = tree

    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hitbox
    weld.Part1 = primary
    weld.Parent = hitbox

    hitbox.Touched:Connect(function(hit)
        OnTreeHitConnect(hit, tree)
    end)
end

local function RemoveHitboxFromTree(tree)
    local hitbox = tree:FindFirstChild("HitBoxForTree")
    if hitbox then
        hitbox:Destroy()
    end
end

local function UpdateTreeHitboxes()
    if not TreeHitboxesActive then return end
    
    for _, tree in ipairs(TreeFold:GetChildren()) do
        local isCorrectType = tree:IsA("Model") or tree:IsA("BasePart")
        local isSelected = table.find(SelectedTrees, tree.Name)
        
        if isCorrectType and isSelected then
            local hasHitbox = tree:FindFirstChild("HitBoxForTree")
            
            if hasHitbox then
                local hitbox = tree:FindFirstChild("HitBoxForTree")
                if hitbox and hitbox.Size.X ~= TreeHitBoxSize then
                    hitbox.Size = Vector3.new(TreeHitBoxSize, TreeHitBoxSize, TreeHitBoxSize)
                end
            else
                CreateHitboxForTree(tree)
            end
        elseif tree:FindFirstChild("HitBoxForTree") and not isSelected then
            RemoveHitboxFromTree(tree)
        end
    end
end 

local function AddAllTreeHitboxes()
    TreeHitboxesActive = true
    for _, tree in ipairs(TreeFold:GetChildren()) do
        local isCorrectType = tree:IsA("Model") or tree:IsA("BasePart")
        local isSelected = table.find(SelectedTrees, tree.Name)
        
        if isCorrectType and isSelected then
            CreateHitboxForTree(tree)
        end
    end
end

local function RemoveAllTreeHitboxes()
    TreeHitboxesActive = false
    for _, tree in ipairs(TreeFold:GetChildren()) do
        if tree:IsA("Model") or tree:IsA("BasePart") then
            RemoveHitboxFromTree(tree)
        end
    end
end

TreeFold.ChildAdded:Connect(function(child)
    local isCorrectType = child:IsA("Model") or child:IsA("BasePart")
    local isSelected = table.find(SelectedTrees, child.Name)
    
    if TreeHitboxesActive and isCorrectType and isSelected then
        wait(0.1)
        CreateHitboxForTree(child)
    end
end)

-- ===== [[ Performance ]] ===== --

local performanceFlags = {
    ["CSGLevelOfDetailSwitchingDistance"] = "0",      
    ["CSGLevelOfDetailSwitchingDistanceL12"] = "0",   
    ["CSGLevelOfDetailSwitchingDistanceL23"] = "0",   
    ["CSGLevelOfDetailSwitchingDistanceL34"] = "0",   
    
    ["DebugGraphicsPreferD3D11"] = "True",           
    ["DebugGraphicsPreferVulkan"] = "False",         
    ["DebugGraphicsPreferOpenGL"] = "False",         
    
    ["TextureQualityOverrideEnabled"] = "True",      
    ["TextureQualityOverride"] = "1",                
    
    ["DebugForceMSAASamples"] = "1",                 
    
    ["DebugFRMQualityLevelOverride"] = "0",          
    ["FRMMaxGrassDistance"] = "0",                   
    ["FRMMinGrassDistance"] = "0",                   
    ["GrassMovementReducedMotionFactor"] = "0",      
    
    ["DebugPauseVoxelizer"] = "True",               
    
    ["DisableDPIScale"] = "True",                   
    ["HandleAltEnterFullscreenManually"] = "False", 
    
    ["RenderGpuTextureCompressor"] = "True",        
    ["FastGPULightCulling3"] = "True",              
    ["DebugRenderingSetDeterministic"] = "True",    
    ["DisablePostFx"] = "True",                     
    ["DebugPerfMode"] = "True",                     
    ["DebugPauseVoxelizer"] = "True",               
    
    ["DebugForceMSAASamples"] = "1",                
    ["DebugFRMQualityLevelOverride"] = "0",         
    ["GraphicsSettingsOnlyShowValidModes"] = "True",
    ["TextureQualityOverrideEnabled"] = "True",     
    ["TextureQualityOverride"] = "1",               
    
    ["DisableDPIScale"] = "True",                   
    ["HandleAltEnterFullscreenManually"] = "False", 
    ["PreloadMinimalFonts"] = "True",               
    
    ["DefaultMeshCacheSizeMB"] = "128",             
    ["AnimationClipMemCacheEnabled"] = "True",      
    
    ["CameraMaxZoomDistance"] = "500",              
    ["TerrainOTAMaxTextureSize"] = "512",           
    
    ["ConnectionMTUSize"] = "576",                  
    ["S2PhysicsSenderRate"] = "60",                 
    
    ["ESGamePerfMonitorEnabled"] = "False",         
    ["GpuVsCpuBoundTelemetry"] = "False",           
    
    ["VideoCaptureServiceEnabled"] = "False",       
    ["BaseNetworkMetrics"] = "False",               
}

local function applyFlags()
    for flag, targetValue in pairs(performanceFlags) do
        local success, currentValue = pcall(function()
            return getfflag(flag)
        end)
        
        if success and currentValue ~= nil and currentValue ~= targetValue then
            pcall(function()
                setfflag(flag, targetValue)
            end)
        end
    end
end

applyFlags()

task.spawn(function()
    while true do
        task.wait(15)
        applyFlags()
    end
end)

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    applyFlags()
end)

-- ===== [[ SCRIPT ]] ===== --

repeat task.wait() until game:IsLoaded()

local settings = {
    playerGui = game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui"),
    interface = nil,
    fishingCatchFrame = nil,
    timingBar = nil,
    successArea = nil
}

settings.interface = settings.playerGui and settings.playerGui:FindFirstChild("Interface")
settings.fishingCatchFrame = settings.interface and settings.interface:FindFirstChild("FishingCatchFrame")
settings.timingBar = settings.fishingCatchFrame and settings.fishingCatchFrame:FindFirstChild("TimingBar")
settings.successArea = settings.timingBar and settings.timingBar:FindFirstChild("SuccessArea")

if settings.successArea then
    settings.successArea:GetPropertyChangedSignal("Size"):Connect(function()
        settings.successArea.Position = UDim2.new(0.5, 0, 0, 0)
        settings.successArea.Size = UDim2.new(1, 0, 1, 0)
    end)
end

WindUI:AddTheme({
    Name = "BlueVoid", 
    Accent = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#000011"), Transparency = 0.05 },
        ["100"] = { Color = Color3.fromHex("#000022"), Transparency = 0.05 },
    }, {
        Rotation = 0,
    }),   
    Outline = Color3.fromHex("#001133"),
    Text = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#0066cc"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#0088ff"), Transparency = 0 },
    }, {
        Rotation = 0,
    }),   
    Placeholder = Color3.fromHex("#004488"),
    Button = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#000022"), Transparency = 0.04 },
        ["100"] = { Color = Color3.fromHex("#000033"), Transparency = 0.04 },
    }, {
        Rotation = 0,
    }),   
    Icon = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#0066cc"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#0088ff"), Transparency = 0 },
    }, {
        Rotation = 0,
    }),   
})

local Window = WindUI:CreateWindow({
    Title = "Voidex Hub",
    Icon = "loader-pinwheel",
    Author = "by someone",
    Theme = "BlueVoid",
    HideSearchBar = false,
    ScrollBarEnabled = true,
})

local tagGradient = WindUI:Gradient({
    ["0"] = { Color = Color3.fromHex("#0066cc"), Transparency = 0 },
    ["100"] = { Color = Color3.fromHex("#0088ff"), Transparency = 0 },
}, {
    Rotation = 0,
})

Window:SetToggleKey(Enum.KeyCode.V)

Window:EditOpenButton({
    Title = "Open Voidex",
    Icon = "loader-pinwheel",
    CornerRadius = UDim.new(0, 16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromRGB(255, 0, 255), Color3.fromRGB(0, 0, 255)),
    Draggable = true
})

local Tabs = {}

Tabs.Info = Window:Tab({
    Title = "Introduction",
    Icon = "info",
    Locked = false,
})
Tabs.Tut = Window:Tab({
    Title = "GuideBook",
    Icon = "book-marked",
})
Tabs.Combat = Window:Tab({
    Title = "Combat",
    Icon = "sword",
    Desc = ""
})
Tabs.Fun = Window:Tab({
    Title = "Fun",
    Icon = "star",
    Desc = ""
})
Tabs.Camp = Window:Tab({
    Title = "Auto",
    Icon = "repeat-2",
    Desc = ""
})
Tabs.br = Window:Tab({
    Title = "Bring",
    Icon = "package",
    Desc = ""
})
Tabs.Fly = Window:Tab({
    Title = "Player",
    Icon = "user",
    Desc = ""
})
Tabs.esp = Window:Tab({
    Title = "Esp",
    Icon = "eye",
    Desc = ""
})
Tabs.Tp = Window:Tab({
    Title = "Teleport",
    Icon = "map",
    Desc = ""
})

Tabs.Vision = Window:Tab({
    Title = "Environment",
    Icon = "earth",
    Desc = ""
})

Tabs.Misc = Window:Tab({
    Title = "Other",
    Icon = "chart-bar-big",
    Desc = ""
})

Window:SelectTab(1)

AboutSection = Tabs.Info:Section({ 
    Title = "About Voidex",
})

AboutSection:Image({
    Image = "https://chatgpt.com/backend-api/estuary/public_content/enc/eyJpZCI6Im1fNjk3MWRhODhjOTYwODE5MWIwNjFiM2VjYWYxN2M2ZjM6ZmlsZV8wMDAwMDAwMGM3NGM3MjA4OTQzODliYzM0NDk5MTczYSIsInRzIjoiMjA0NzUiLCJwIjoicHlpIiwiY2lkIjoiMSIsInNpZyI6IjE1ZjU4ZjIzMWQzOGRlYjVlMTRjOWNiYTk3MWY1ZjdjMDk0ZjJmYzcyMTk0MzNmZWI0N2QxZjA2OTJkMDgzMDEiLCJ2IjoiMCIsImdpem1vX2lkIjpudWxsLCJjcyI6bnVsbCwiY3AiOm51bGwsIm1hIjpudWxsfQ==",
    AspectRatio = "16:9",
    Radius = 9,
})

AboutSection:Space({ Columns = 3 })

AboutSection:Section({ 
    Title = "VOIDEX",
    TextSize = 24,
})

AboutSection:Space()

AboutSection:Section({
    Title = "Voidex is a modern roblox script hub built to automate gameplay actions and deliver smooth optimized performance with a clean powerful feel",
    TextSize = 18,
    TextTransparency = .35,
     FontWeight = Enum.FontWeight.Medium,
})

Tabs.Info:Button({
    Title = "Destroy Window",
    Color = Color3.fromHex("#ff4830"),
    Justify = "Center",
    Icon = "shredder",
    IconAlign = "Left",
    Callback = function()
        Window:Destroy()
    end
})

Tabs.Info:Keybind({
    Title = "Keybind",
    Desc = "Keybind to open and close ui",
    Value = "F",
    Callback = function(v)
        Window:SetToggleKey(Enum.KeyCode[v])
    end
})

Tabs.Tut:Section({ Title = "Tutorial", Icon = "badge-question-mark" })

Tabs.Tut:Paragraph({
    Title = "Guide on making all features fully functional",
    Desc = "I suggest playing alone to be more effective. First, Use chop aura and chop many trees as much as possible then turn on auto upgrade campfire and it will teleport chopped woods into fire and max out the level of campfire. Or you can use the auto days farm gui for afk auto farming, it will do everything.",
    Locked = false
})

Tabs.Combat:Section({ Title = "Aura", Icon = "star" })

Tabs.Combat:Toggle({
    Title = "Kill Aura",
    Value = false,
    Callback = function(state)
        killAuraToggle = state
        if state then
            task.spawn(killAuraLoop)
         else
            local tool, _ = getAnyToolWithDamageID(false)
            unequipTool(tool)
        end
    end
})

Tabs.Combat:Toggle({
    Title = "Chop Aura",
    Value = false,
    Callback = function(state)
        chopAuraToggle = state
        if state then
            task.spawn(chopAuraLoop)
        else
            local tool, _ = getAnyToolWithDamageID(true)
            unequipTool(tool)
        end
    end
})

Tabs.Combat:Section({ Title = "Settings", Icon = "settings" })

Tabs.Combat:Slider({
    Title = "Aura Radius",
    Value = { Min = 1, Max = 200, Default = 100 },
    Callback = function(value)
        auraRadius = math.clamp(value, 1, 200)
    end
})

Tabs.Combat:Section({
    Title = "HitBox Mobs",
    Icon = "swords",
})
Tabs.Combat:Dropdown({
    Title = "Select Mobs to add Hitbox",
    Values = MobsList,
    Multi = true,
    AllowNone = false,
    Callback = function(options) 
        SelectedMobs = options
        UpdateHitboxes()
    end
})

Tabs.Combat:Slider({
    Title = "Hitbox Size",
    Step = 1,
    Value = {
        Min = 20,
        Max = 100,
        Default = 50,
    },
    Callback = function(value)
        HitBoxSize = value
        if HitboxesActive then
            for _, mob in ipairs(MobsFolder:GetChildren()) do
                if mob:IsA("Model") and table.find(SelectedMobs, mob.Name) then
                    local hitbox = mob:FindFirstChild("HitBoxForMob")
                    if hitbox then
                        hitbox.Size = Vector3.new(HitBoxSize, HitBoxSize, HitBoxSize)
                    end
                end
            end
        end
    end
})

Tabs.Combat:Toggle({
    Title = "Add Hitbox",
    Desc = "Will add hitbox but invisible for performance",
    Icon = "sword",
    Type = "Toggle",
    Default = false,
    Callback = function(state) 
        if state then
            pcall(function()
                AddAllHitboxes()
            end)
        else
                RemoveAllHitboxes()
        end
    end
})

Tabs.Misc:Section({ Title = "Chests", Icon = "package-2" })

Tabs.Misc:Toggle({
    Title = "Auto Open Chests",
    Locked = false,
    Value = false,
    Callback = function(v)
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        if not _G.AutoChestData then
            _G.AutoChestData = {running = false, originalCFrame = nil}
        end

        local function getChests()
            local chests = {}
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and string.find(obj.Name, "Item Chest") then
                    table.insert(chests, obj)
                end
            end
            return chests
        end

        local function getPrompt(model)
            local prompts = {}
            for _, obj in ipairs(model:GetDescendants()) do
                if obj:IsA("ProximityPrompt") then
                    table.insert(prompts, obj)
                end
            end
            return prompts
        end

        if v then
            if _G.AutoChestData.running then return end
            _G.AutoChestData.running = true
            _G.AutoChestData.originalCFrame = humanoidRootPart.CFrame
            task.spawn(function()
                while _G.AutoChestData.running do
                    local chests = getChests()
                    for _, chest in ipairs(chests) do
                        if not _G.AutoChestData.running then break end
                        local part = chest.PrimaryPart or chest:FindFirstChildWhichIsA("BasePart")
                        if part then
                            humanoidRootPart.CFrame = part.CFrame + Vector3.new(0, 6, 0)
                            local prompts = getPrompt(chest)
                            for _, prompt in ipairs(prompts) do
                                fireproximityprompt(prompt, math.huge)
                            end
                            local t = tick()
                            while _G.AutoChestData.running and tick() - t < 4 do task.wait() end
                        end
                    end
                    task.wait(0.1)
                end
            end)
        else
            _G.AutoChestData.running = false
            if _G.AutoChestData.originalCFrame then
                humanoidRootPart.CFrame = _G.AutoChestData.originalCFrame
            end
        end
    end
})

Tabs.Misc:Section({ Title = "Auto Feed", Icon = "utensils" })

Tabs.Misc:Dropdown({
    Title = "Select Food",
    Desc = "Choose the food",
    Values = alimentos,
    Value = selectedFood,
    Multi = true,
    Callback = function(value)
        selectedFood = value
    end
})

Tabs.Misc:Input({
    Title = "Eat Amount",
    Desc = "Eat when hunger reaches this %",
    Value = tostring(hungerThreshold),
    Placeholder = "Ex 50",
    Numeric = true,
    Callback = function(value)
        local n = tonumber(value)
        if n then
            hungerThreshold = math.clamp(n, 0, 100)
        end
    end
})

Tabs.Misc:Toggle({
    Title = "Auto Eat",
    Desc = "",
    Value = false,
    Callback = function(state)
        autoFeedToggle = state
        if state then
            task.spawn(function()
                while autoFeedToggle do
                    task.wait(0.05)

                    local currentHunger = ghn()
                    if currentHunger <= hungerThreshold and #selectedFood > 0 then
                        while currentHunger < 100 and autoFeedToggle do
                            local ateSomething = false

                            for _, foodName in ipairs(selectedFood) do
                                for _, item in ipairs(Workspace.Items:GetChildren()) do
                                    if item.Name == foodName and item.Parent then
                                        pcall(function()
                                            ReplicatedStorage.RemoteEvents.RequestConsumeItem:InvokeServer(item)
                                        end)
                                        ateSomething = true
                                        task.wait(0.05)
                                        currentHunger = ghn()
                                        if currentHunger >= 100 then
                                            break
                                        end
                                    end
                                end
                                if currentHunger >= 100 then
                                    break
                                end
                            end

                            if not ateSomething then
                                break
                            end
                        end
                    end
                end
            end)
        end
    end
})

Tabs.Camp:Section({
    Title = "AutoPlant",
    Icon = "sprout",
})
Tabs.Camp:Toggle({
    Title = "Infinite Saplings Plant",
    Desc = "Plant saplings infinitely around your base",
    Type = "Toggle",
    Default = false,
    Callback = function(state) 
        if state then
            pcall(function()
                StartAutoPlant()
            end)
        else
            StopAutoPlant()
        end
    end
})

Tabs.Camp:Slider({
    Title = "Plant Radius",
    Step = 1,
    Value = {
        Min = 50,
        Max = 100,
        Default = 50,
    },
    Callback = function(value)
        _G.AutoSapRadius = value
    end
})


Tabs.Camp:Section({ Title = "Auto Upgrade Campfire", Icon = "flame" })

local selectedCampfireItems = {}

Tabs.Camp:Dropdown({
    Title = "Choose the item to Upgrade Campfire",
    Values = campfireFuelItems,
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        selectedCampfireItems = options or {}
    end
})

Tabs.Camp:Toggle({
    Title = "Auto Upgrade Campfire",
    Value = false,
    Callback = function(checked)
        autoUpgradeCampfireEnabled = checked
        if checked then
            task.spawn(function()
                while autoUpgradeCampfireEnabled do
                    if #selectedCampfireItems > 0 then
                        for _, selectedItem in ipairs(selectedCampfireItems) do
                            local items = {}

                            for _, item in ipairs(workspace:WaitForChild("Items"):GetChildren()) do
                                if item.Name == selectedItem then
                                    table.insert(items, item)
                                end
                            end

                            local count = math.min(10, #items)
                            for i = 1, count do
                                moveItemToPos(items[i], campfireDropPos)
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
        end
    end
})

Tabs.Camp:Section({ Title = "AutoScrap", Icon = "cog" })

Tabs.Camp:Dropdown({
    Title = "Choose the item to AutoScrap",
    Values = scrapjunkItems,
    Multi = false,
    AllowNone = true,
    Callback = function(option)
        selectedScrapItem = option
    end
})

Tabs.Camp:Toggle({
    Title = "Auto Scrap",
    Value = false,
    Callback = function(checked)
        autoScrapItemsEnabled = checked
        if checked then
            task.spawn(function()
                while autoScrapItemsEnabled do
                    if selectedScrapItem then
                        local items = {}
                        
                        for _, item in ipairs(workspace:WaitForChild("Items"):GetChildren()) do
                            if item.Name == selectedScrapItem then
                                table.insert(items, item)
                            end
                        end

                        local count = math.min(10, #items)
                        for i = 1, count do
                            moveItemToPos(items[i], autoScrapPos)
                        end
                    end
                    
                    task.wait(1)
                end
            end)
        end
    end
})


Tabs.Camp:Section({ Title = "Auto Cook Food", Icon = "flame" })

Tabs.Camp:Dropdown({
    Title = "Food List",
    Values = autocookItems,
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        for _, itemName in ipairs(autocookItems) do
            autoCookEnabledItems[itemName] = table.find(options, itemName) ~= nil
        end
    end
})

Tabs.Camp:Toggle({
    Title = "Auto Cook Food",
    Value = false,
    Callback = function(state)
        autoCookEnabled = state
    end
})

coroutine.wrap(function()
    while true do
        if autoCookEnabled then
            for itemName, enabled in pairs(autoCookEnabledItems) do
                if enabled then
                    for _, item in ipairs(Workspace:WaitForChild("Items"):GetChildren()) do
                        if item.Name == itemName then
                            moveItemToPos(item, campfireDropPos)
                        end
                    end
                end
            end
        end
        task.wait(0.5)
    end
end)()

Tabs.Camp:Section({ Title = "Auto Craft Items", Icon = "hammer" })

Tabs.Camp:Dropdown({
    Title = "Auto Craft Items",
    Desc = "Choose items to craft",
    Values = craftableItems,
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        selectedCraftItems = options or {}
    end
})

Tabs.Camp:Toggle({
    Title = "Auto Craft Items",
    Value = false,
    Callback = function(checked)
        autoCraftEnabled = checked
        if checked then
            task.spawn(function()
                while autoCraftEnabled do
                    if #selectedCraftItems > 0 then
                        for _, itemName in ipairs(selectedCraftItems) do
                            local args = { itemName }
                            game:GetService("ReplicatedStorage")
                                :WaitForChild("RemoteEvents")
                                :WaitForChild("CraftItem")
                                :InvokeServer(unpack(args))
                        end
                    end
                    task.wait(0.5)
                end
            end)
        end
    end
})

Tabs.Camp:Section({ Title = "Crafting Bench", Icon = "wrench" })

Tabs.Camp:Dropdown({
    Title = "Auto Upgrade Bench",
    Desc = "Choose which benches to auto-upgrade",
    Values = craftingBenchItems,
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        selectedBenchItems = options or {}
    end
})

Tabs.Camp:Toggle({
    Title = "Auto Upgrade Bench",
    Value = false,
    Callback = function(checked)
        autoUpgradeBenchEnabled = checked
        if checked then
            task.spawn(function()
                while autoUpgradeBenchEnabled do
                    if #selectedBenchItems > 0 then
                        for _, bench in ipairs(selectedBenchItems) do
                            local args = { bench }
                            game:GetService("ReplicatedStorage")
                                :WaitForChild("RemoteEvents")
                                :WaitForChild("CraftItem")
                                :InvokeServer(unpack(args))
                        end
                    end
                    task.wait(0.5)
                end
            end)
        end
    end
})

Tabs.Tp:Section({ Title = "Scan Map", Icon = "map" })

Tabs.Tp:Toggle({
    Title = "Scan Map",
    Desc = "Might not work for some executors",
    Default = false,
    Callback = function(state)
        scan_map = state

        if not state then
            if type(tp1) == "function" and scan_map_was_on then
                tp1()
            end
            scan_map_was_on = false
            return
        else
            scan_map_was_on = true
        end

        task.spawn(function()
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:WaitForChild("HumanoidRootPart", 3)
            if not hrp then return end

            local map = workspace:FindFirstChild("Map")
            if not map then return end

            local foliage = map:FindFirstChild("Foliage") or map:FindFirstChild("Landmarks")
            if not foliage then return end

            while scan_map do
                local trees = {}
                for _, obj in ipairs(foliage:GetChildren()) do
                    if obj.Name == "Small Tree" and obj:IsA("Model") then
                        local trunk = obj:FindFirstChild("Trunk") or obj.PrimaryPart
                        if trunk then
                            table.insert(trees, trunk)
                        end
                    end
                end

                for _, trunk in ipairs(trees) do
                    if not scan_map then break end
                    if trunk and trunk.Parent then
                        local treeCFrame = trunk.CFrame
                        local rightVector = treeCFrame.RightVector
                        local targetPosition = treeCFrame.Position + rightVector * 69 + Vector3.new(0, 15, 69)
                        
                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)

                        local footPart = Instance.new("Part")
                        footPart.Size = Vector3.new(10, 1, 10)
                        footPart.Anchored = true
                        footPart.CanCollide = true
                        footPart.Transparency = 1
                        footPart.BrickColor = BrickColor.new("Bright yellow")
                        footPart.CFrame = CFrame.new(targetPosition - Vector3.new(0, 3, 0))
                        footPart.Parent = workspace

                        game.Debris:AddItem(footPart, 1)

                        task.wait(0.01)
                    end
                end
                task.wait(0.25)
            end
        end)
    end
})

Tabs.Tp:Section({ Title = "Teleport", Icon = "map-pin" })

Tabs.Tp:Button({
    Title = "Custom Teleport GUI",
    Locked = false,
    Callback = function()
        loadstring(game:HttpGet("https://paste.rs/pLSf7"))()
    end
})

Tabs.Tp:Button({
    Title = "Teleport to Campfire",
    Locked = false,
    Callback = function()
        tp1()
    end
})

Tabs.Tp:Button({
    Title = "Teleport to Stronghold",
    Locked = false,
    Callback = function()
        tp2()
    end
})

Tabs.Tp:Button({
    Title = "Teleport to Safe Zone",
    Callback = function()
        if not workspace:FindFirstChild("SafeZonePart") then
            local createpart = Instance.new("Part")
            createpart.Name = "SafeZonePart"
            createpart.Size = Vector3.new(30, 3, 30)
            createpart.Position = Vector3.new(0, 350, 0)
            createpart.Anchored = true
            createpart.CanCollide = true
            createpart.Transparency = 0.8
            createpart.Color = Color3.fromRGB(255, 0, 0)
            createpart.Parent = workspace
        end
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        hrp.CFrame = CFrame.new(0, 360, 0)
    end
})

Tabs.Tp:Button({
    Title = "Teleport to Trader",
    Callback = function()
        local pos = Vector3.new(-37.08, 3.98, -16.33)
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        hrp.CFrame = CFrame.new(pos)
    end
})

Tabs.Tp:Section({ Title = "Tree", Icon = "tree-deciduous" })

Tabs.Tp:Button({
    Title = "Teleport to Random Tree",
    Callback = function()
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart", 3)
        if not hrp then return end

        local map = workspace:FindFirstChild("Map")
        if not map then return end

        local foliage = map:FindFirstChild("Foliage") or map:FindFirstChild("Landmarks")
        if not foliage then return end

        local trees = {}
        for _, obj in ipairs(foliage:GetChildren()) do
            if obj.Name == "Small Tree" and obj:IsA("Model") then
                local trunk = obj:FindFirstChild("Trunk") or obj.PrimaryPart
                if trunk then
                    table.insert(trees, trunk)
                end
            end
        end

        if #trees > 0 then
            local trunk = trees[math.random(1, #trees)]
            local treeCFrame = trunk.CFrame
            local rightVector = treeCFrame.RightVector
            local targetPosition = treeCFrame.Position + rightVector * 3
            hrp.CFrame = CFrame.new(targetPosition)
        end
    end
})

Tabs.Tp:Section({ Title = "Children", Icon = "eye" })

local MobDropdown = Tabs.Tp:Dropdown({
    Title = "Select Child",
    Values = currentMobNames,
    Multi = false,
    AllowNone = true,
    Callback = function(options)
        selectedMob = options[#options] or currentMobNames[1] or nil
    end
})

Tabs.Tp:Button({
    Title = "Refresh List",
    Locked = false,
    Callback = function()
        currentMobs, currentMobNames = getMobs()
        if #currentMobNames > 0 then
            selectedMob = currentMobNames[1]
            MobDropdown:Refresh(currentMobNames)
        else
            selectedMob = nil
            MobDropdown:Refresh({ "No child found" })
        end
    end
})

Tabs.Tp:Button({
    Title = "Teleport to Child",
    Locked = false,
    Callback = function()
        if selectedMob and currentMobs then
            for i, name in ipairs(currentMobNames) do
                if name == selectedMob then
                    local targetMob = currentMobs[i]
                    if targetMob then
                        local part = targetMob.PrimaryPart or targetMob:FindFirstChildWhichIsA("BasePart")
                        if part and game.Players.LocalPlayer.Character then
                            local hrp = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                hrp.CFrame = part.CFrame + Vector3.new(0, 5, 0)
                            end
                        end
                    end
                    break
                end
            end
        end
    end
})


Tabs.Tp:Section({ Title = "Chest", Icon = "box" })

local ChestDropdown = Tabs.Tp:Dropdown({
    Title = "Select Chest",
    Values = currentChestNames,
    Multi = false,
    AllowNone = true,
    Callback = function(options)
        selectedChest = options[#options] or currentChestNames[1] or nil
    end
})

Tabs.Tp:Button({
    Title = "Refresh List",
    Locked = false,
    Callback = function()
        currentChests, currentChestNames = getChests()
        if #currentChestNames > 0 then
            selectedChest = currentChestNames[1]
            ChestDropdown:Refresh(currentChestNames)
        else
            selectedChest = nil
            ChestDropdown:Refresh({ "No chests found" })
        end
    end
})

Tabs.Tp:Button({
    Title = "Teleport to Chest",
    Locked = false,
    Callback = function()
        if selectedChest and currentChests then
            local chestIndex = 1
            for i, name in ipairs(currentChestNames) do
                if name == selectedChest then
                    chestIndex = i
                    break
                end
            end
            local targetChest = currentChests[chestIndex]
            if targetChest then
                local part = targetChest.PrimaryPart or targetChest:FindFirstChildWhichIsA("BasePart")
                if part and game.Players.LocalPlayer.Character then
                    local hrp = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.CFrame = part.CFrame + Vector3.new(0, 5, 0)
                    end
                end
            end
        end
    end
})

Tabs.br:Button({
    Title = "Super Item Grabber GUI",
    Locked = false,
    Callback = function()
    loadstring(game:HttpGet("https://paste.rs/ernpE"))()
  end
})

Tabs.br:Toggle({
    Title = "Scan Map",
    Default = false,
    Callback = function(state)
        scan_map = state

        if not state then
            if type(tp1) == "function" and scan_map_was_on then
                tp1()
            end
            scan_map_was_on = false
            return
        else
            scan_map_was_on = true
        end

        task.spawn(function()
            local player = Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:WaitForChild("HumanoidRootPart", 3)
            if not hrp then return end

            local map = workspace:FindFirstChild("Map")
            if not map then return end

            local foliage = map:FindFirstChild("Foliage") or map:FindFirstChild("Landmarks")
            if not foliage then return end

            while scan_map do
                local trees = {}
                for _, obj in ipairs(foliage:GetChildren()) do
                    if obj.Name == "Small Tree" and obj:IsA("Model") then
                        local trunk = obj:FindFirstChild("Trunk") or obj.PrimaryPart
                        if trunk then
                            table.insert(trees, trunk)
                        end
                    end
                end

                for _, trunk in ipairs(trees) do
                    if not scan_map then break end
                    if trunk and trunk.Parent then
                        local treeCFrame = trunk.CFrame
                        local rightVector = treeCFrame.RightVector
                        local targetPosition = treeCFrame.Position + rightVector * 69 + Vector3.new(0, 15, 69)
                        
                        hrp.CFrame = CFrame.new(targetPosition)

                        local footPart = Instance.new("Part")
                        footPart.Size = Vector3.new(10, 1, 10)
                        footPart.Anchored = true
                        footPart.CanCollide = true
                        footPart.Transparency = 1
                        footPart.BrickColor = BrickColor.new("Bright yellow")
                        footPart.CFrame = CFrame.new(targetPosition - Vector3.new(0, 3, 0))
                        footPart.Parent = workspace

                        game.Debris:AddItem(footPart, 1)

                        task.wait(0.01)
                    end
                end
                task.wait(0.25)
            end
        end)
    end
})

Tabs.br:Button({
    Title = "Reveal Whole Map",
    Desc = "Visually reveals the whole map",
    Locked = false,
    Callback = function()
        local boundaries = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Boundaries")
        if boundaries then
            for _, obj in pairs(boundaries:GetChildren()) do
                obj:Destroy()
            end
        end
    end
})

-- NEW

local BringSettings = {
    BringPos = {
        "You", "Campfire", "Crafting Bench"
    },
    BringMethod = {
        "Slow", "Normal", "Fast"
    },
    SelectedBringMethod = "Normal",
    SelectedBringPos = "You"
}

local BringFuelSettings = {
    fuelItems = {
        "Log", "Chair", "Coal", "Fuel Canister", "Oil Barrel"
    },
    FuelToBring = {}
}

function BringFuel()
    for _, v in pairs(workspace.Items:GetChildren()) do
        for _, item in ipairs(BringFuelSettings.FuelToBring) do
            if v.Name == item then
                local targetCFrame
                local waitTime = 0.03

                if BringSettings.SelectedBringMethod == "Slow" then
                    waitTime = 0.15
                elseif BringSettings.SelectedBringMethod == "Normal" then
                    waitTime = 0.01
                elseif BringSettings.SelectedBringMethod == "Fast" then
                    waitTime = 0.008
                end

                if BringSettings.SelectedBringPos == "You" then
                    targetCFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 20, 0))
                elseif BringSettings.SelectedBringPos == "Campfire" then
                    targetCFrame = CFrame.new(0, 20, 0)
                elseif BringSettings.SelectedBringPos == "Crafting Bench" then
                    local benchPart = workspace.Map.Campground.CraftingBench.PrimaryPart or workspace.Map.Campground.CraftingBench:FindFirstChildWhichIsA("BasePart")
                    if benchPart then
                        targetCFrame = benchPart.CFrame + Vector3.new(0, 20, 0)
                    end
                end

                if targetCFrame then
                    pcall(function()
                        Drag(v)
                        wait(waitTime)
                        local vPart = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                        if vPart then
                            vPart.CFrame = targetCFrame
                        end
                        wait(waitTime)
                        Undrag(v)
                    end)
                end
            end
        end
    end
end

local BringAllSet = {
    FuelItems = {
        "Log", "Chair", "Coal", "Fuel Canister", "Oil Barrel"
    },
    JunkItems = {
        "Bolt", "Sheet Metal", "Broken Fan", "Old Radio", "Broken Microwave", "Tyre", "Old Car Engine", "Washing Machine", "Cultist Experiment", "Cultist Prototype", "Meteor Shard", "Gold Shard", "UFO Scrap", "Cultist Gem", "Gem of the Forest Fragment", "Feather", "Old Boot"
    },
    FoodItems = {
        "Pumpkin", "Cake", "Cooked Steak", "Cooked Morsel", "Ribs", "Salmon", "Cooked Salmon", "Cooked Ribs", "Mackerel", "Cooked Mackerel", "Steak", "Morsel", "Berry", "Apple", "Carrot", "Chilli", "Stew", "Hearty Stew", "Corn", "Pumpkin", "Meat? Sandwich", "Pumpkin", "Seafood Chowder", "Steak Dinner", "Pumpkin Soup", "BBQ Ribs", "Carrot Cake", "Jar of Jelly", "Mackerel", "Salmon", "Clownfish", "Swordfish", "Jellyfish", "Char", "Eel", "Shark", "Cooked Clownfish", "Cooked Swordfish", "Cooked Jellyfish", "Cooked Char", "Cooked Eel", "Cooked Shark"
    }
}

function BringAll()
    for _, v in pairs(workspace.Items:GetChildren()) do
        local shouldBring = false
        
        for _, category in pairs(BringAllSet) do
            for _, item in ipairs(category) do
                if v.Name == item then
                    shouldBring = true
                    break
                end
            end
            if shouldBring then break end
        end
        
        if shouldBring then
            local targetCFrame
            local waitTime = 0.03

            if BringSettings.SelectedBringMethod == "Slow" then
                waitTime = 0.15
            elseif BringSettings.SelectedBringMethod == "Normal" then
                waitTime = 0.03
            elseif BringSettings.SelectedBringMethod == "Fast" then
                waitTime = 0.003
            end

            if BringSettings.SelectedBringPos == "You" then
                targetCFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 20, 0))
            elseif BringSettings.SelectedBringPos == "Campfire" then
                targetCFrame = CFrame.new(0, 20, 0)
            elseif BringSettings.SelectedBringPos == "Crafting Bench" then
                local benchPart = workspace.Map.Campground.CraftingBench.PrimaryPart or workspace.Map.Campground.CraftingBench:FindFirstChildWhichIsA("BasePart")
                if benchPart then
                    targetCFrame = benchPart.CFrame + Vector3.new(0, 20, 0)
                end
            end

            if targetCFrame then
                pcall(function()
                    Drag(v)
                    wait(waitTime)
                    local vPart = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                    if vPart then
                        vPart.CFrame = targetCFrame
                    end
                    wait(waitTime)
                    Undrag(v)
                end)
            end
        end
    end
end

-- Bring Settings Section
Tabs.br:Section({ 
    Title = "Bring Settings",
})

Tabs.br:Dropdown({
    Title = "Bring Position",
    Desc = "Select where to bring items",
    Values = BringSettings.BringPos,
    Value = BringSettings.SelectedBringPos,
    Callback = function(option)
        BringSettings.SelectedBringPos = option
    end
})

Tabs.br:Dropdown({
    Title = "Bring Method",
    Desc = "Select bring speed",
    Values = BringSettings.BringMethod,
    Value = BringSettings.SelectedBringMethod,
    Callback = function(option)
        BringSettings.SelectedBringMethod = option
    end
})

Tabs.br:Section({ 
    Title = "All Items",
})

Tabs.br:Button({
    Title = "Bring All Items",
    Desc = "Bring all fuel, scrap, and food items",
    Locked = false,
    Callback = function()
        BringAll()
    end
})

Tabs.br:Section({ 
    Title = "Fuel Items",
})

Tabs.br:Dropdown({
    Title = "Select Fuel",
    Desc = "Choose fuel items to bring",
    Values = BringFuelSettings.fuelItems,
    Value = BringFuelSettings.FuelToBring,
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        BringFuelSettings.FuelToBring = option
    end
})

Tabs.br:Button({
    Title = "Bring Fuel Items",
    Desc = "Bring selected fuel items",
    Locked = false,
    Callback = function()
        BringFuel()
    end
})

local BringScrapSettings = {
    junkItems = {
        "Bolt", "Sheet Metal", "Broken Fan", "Old Radio", "Broken Microwave", "Tyre", "Old Car Engine", "Washing Machine", "Cultist Experiment", "Cultist Prototype", "Meteor Shard", "Gold Shard", "UFO Scrap", "Cultist Gem", "Gem of the Forest Fragment", "Feather", "Old Boot"
    },
    ScrapToBring = {}
}

function BringScrap()
    for _, v in pairs(workspace.Items:GetChildren()) do
        for _, item in ipairs(BringScrapSettings.ScrapToBring) do
            if v.Name == item then
                local targetCFrame
                local waitTime = 0.03

                if BringSettings.SelectedBringMethod == "Slow" then
                    waitTime = 0.15
                elseif BringSettings.SelectedBringMethod == "Normal" then
                    waitTime = 0.03
                elseif BringSettings.SelectedBringMethod == "Fast" then
                    waitTime = 0.003
                end

                if BringSettings.SelectedBringPos == "You" then
                    targetCFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 20, 0))
                elseif BringSettings.SelectedBringPos == "Campfire" then
                    targetCFrame = CFrame.new(0, 20, 0)
                elseif BringSettings.SelectedBringPos == "Crafting Bench" then
                    local benchPart = workspace.Map.Campground.CraftingBench.PrimaryPart or workspace.Map.Campground.CraftingBench:FindFirstChildWhichIsA("BasePart")
                    if benchPart then
                        targetCFrame = benchPart.CFrame + Vector3.new(0, 20, 0)
                    end
                end

                if targetCFrame then
                    pcall(function()
                        Drag(v)
                        wait(waitTime)
                        local vPart = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                        if vPart then
                            vPart.CFrame = targetCFrame
                        end
                        wait(waitTime)
                        Undrag(v)
                    end)
                end
            end
        end
    end
end

Tabs.br:Section({ 
    Title = "Scrap Items",
})

Tabs.br:Dropdown({
    Title = "Select Scrap",
    Desc = "Choose scrap items to bring",
    Values = BringScrapSettings.junkItems,
    Value = BringScrapSettings.ScrapToBring,
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        BringScrapSettings.ScrapToBring = option
    end
})

Tabs.br:Button({
    Title = "Bring Scrap Items",
    Desc = "Bring selected scrap items",
    Locked = false,
    Callback = function()
        BringScrap()
    end
})

local BringFoodSettings = {
    foodItems = {
        "Pumpkin", "Cake", "Cooked Steak", "Cooked Morsel", "Ribs", "Salmon", "Cooked Salmon", "Cooked Ribs", "Mackerel", "Cooked Mackerel", "Steak", "Morsel", "Berry", "Apple", "Carrot", "Chilli", "Stew", "Hearty Stew", "Corn", "Pumpkin", "Meat? Sandwich", "Pumpkin", "Seafood Chowder", "Steak Dinner", "Pumpkin Soup", "BBQ Ribs", "Carrot Cake", "Jar of Jelly", "Mackerel", "Salmon", "Clownfish", "Swordfish", "Jellyfish", "Char", "Eel", "Shark", "Cooked Clownfish", "Cooked Swordfish", "Cooked Jellyfish", "Cooked Char", "Cooked Eel", "Cooked Shark"
    },
    FoodToBring = {}
}

function BringFood()
    for _, v in pairs(workspace.Items:GetChildren()) do
        for _, item in ipairs(BringFoodSettings.FoodToBring) do
            if v.Name == item then
                local targetCFrame
                local waitTime = 0.03

                if BringSettings.SelectedBringMethod == "Slow" then
                    waitTime = 0.15
                elseif BringSettings.SelectedBringMethod == "Normal" then
                    waitTime = 0.03
                elseif BringSettings.SelectedBringMethod == "Fast" then
                    waitTime = 0.003
                end

                if BringSettings.SelectedBringPos == "You" then
                    targetCFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 20, 0))
                elseif BringSettings.SelectedBringPos == "Campfire" then
                    targetCFrame = CFrame.new(0, 20, 0)
                elseif BringSettings.SelectedBringPos == "Crafting Bench" then
                    local benchPart = workspace.Map.Campground.CraftingBench.PrimaryPart or workspace.Map.Campground.CraftingBench:FindFirstChildWhichIsA("BasePart")
                    if benchPart then
                        targetCFrame = benchPart.CFrame + Vector3.new(0, 20, 0)
                    end
                end

                if targetCFrame then
                    pcall(function()
                        Drag(v)
                        wait(waitTime)
                        local vPart = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                        if vPart then
                            vPart.CFrame = targetCFrame
                        end
                        wait(waitTime)
                        Undrag(v)
                    end)
                end
            end
        end
    end
end

Tabs.br:Section({ 
    Title = "Food Items",
})

Tabs.br:Dropdown({
    Title = "Select Foods",
    Desc = "Choose food items to bring",
    Values = BringFoodSettings.foodItems,
    Value = BringFoodSettings.FoodToBring,
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        BringFoodSettings.FoodToBring = option
    end
})

Tabs.br:Button({
    Title = "Bring Food Items",
    Desc = "Bring selected food items",
    Locked = false,
    Callback = function()
        BringFood()
    end
})

local BringHealingSettings = {
    MedicalItems = {"Bandage", "MedKit"},
    MedicalItemsToBring = {}
}

function BringHealingItems()
    for _, v in pairs(workspace.Items:GetChildren()) do
        for _, item in ipairs(BringHealingSettings.MedicalItemsToBring) do
            if v.Name == item then
                local targetCFrame
                local waitTime = 0.03

                if BringSettings.SelectedBringMethod == "Slow" then
                    waitTime = 0.15
                elseif BringSettings.SelectedBringMethod == "Normal" then
                    waitTime = 0.03
                elseif BringSettings.SelectedBringMethod == "Fast" then
                    waitTime = 0.003
                end

                if BringSettings.SelectedBringPos == "You" then
                    targetCFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Ve)
                elseif BringSettings.SelectedBringPos == "Campfire" then
                    targetCFrame = CFrame.new(0, 20, 0)
                elseif BringSettings.SelectedBringPos == "Crafting Bench" then
                    local benchPart = workspace.Map.Campground.CraftingBench.PrimaryPart or workspace.Map.Campground.CraftingBench:FindFirstChildWhichIsA("BasePart")
                    if benchPart then
                        targetCFrame = benchPart.CFrame + Vector3.new(0, 20, 0)
                    end
                end

                if targetCFrame then
                    pcall(function()
                        Drag(v)
                        wait(waitTime)
                        local vPart = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                        if vPart then
                            vPart.CFrame = targetCFrame
                        end
                        wait(waitTime)
                        Undrag(v)
                    end)
                end
            end
        end
    end
end

Tabs.br:Section({ 
    Title = "Medical Items",
})

Tabs.br:Dropdown({
    Title = "Select Medical",
    Desc = "Choose medical items to bring",
    Values = BringHealingSettings.MedicalItems,
    Value = BringHealingSettings.MedicalItemsToBring,
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        BringHealingSettings.MedicalItemsToBring = option
    end
})

Tabs.br:Button({
    Title = "Bring Medical Items",
    Desc = "Bring selected medical items",
    Locked = false,
    Callback = function()
        BringHealingItems()
    end
})

local BringGearSettings = {
    GearItems = {"Revolver", "Rifle", "Revolver Ammo", "Rifle Ammo", "Infernal Sack", "Giant Sack", "Good Sack", "Strong Axe", "Good Axe", "Frozen Shuriken", "Tactical Shotgun", "Crossbow", "Infernal Crossbow", "Snowball", "Kunai", "Leather Body", "Poison Armour", "Iron Body", "Thorn Body", "Obsidiron Body", "Cultist Staff", "Riot Shield", "Alien Armour", "Axe Trim Kit", "Armour Trim Kit", "Old Rod", "Good Rod", "Strong Rod"},
    GearToBring = {}
}

function BringGearItems()
    for _, v in pairs(workspace.Items:GetChildren()) do
        for _, item in ipairs(BringGearSettings.GearToBring) do
            if v.Name == item then
                local targetCFrame
                local waitTime = 0.03

                if BringSettings.SelectedBringMethod == "Slow" then
                    waitTime = 0.15
                elseif BringSettings.SelectedBringMethod == "Normal" then
                    waitTime = 0.03
                elseif BringSettings.SelectedBringMethod == "Fast" then
                    waitTime = 0.003
                end

                if BringSettings.SelectedBringPos == "You" then
                    targetCFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Ve)
                elseif BringSettings.SelectedBringPos == "Campfire" then
                    targetCFrame = CFrame.new(0, 20, 0)
                elseif BringSettings.SelectedBringPos == "Crafting Bench" then
                    local benchPart = workspace.Map.Campground.CraftingBench.PrimaryPart or workspace.Map.Campground.CraftingBench:FindFirstChildWhichIsA("BasePart")
                    if benchPart then
                        targetCFrame = benchPart.CFrame + Vector3.new(0, 20, 0)
                    end
                end

                if targetCFrame then
                    pcall(function()
                        Drag(v)
                        wait(waitTime)
                        local vPart = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                        if vPart then
                            vPart.CFrame = targetCFrame
                        end
                        wait(waitTime)
                        Undrag(v)
                    end)
                end
            end
        end
    end
end

Tabs.br:Section({ 
    Title = "Gear Items",
})

Tabs.br:Dropdown({
    Title = "Select Gear",
    Desc = "Choose gear items to bring",
    Values = BringGearSettings.GearItems,
    Value = BringGearSettings.GearToBring,
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        BringGearSettings.GearToBring = option
    end
})

Tabs.br:Button({
    Title = "Bring Gear Items",
    Desc = "Bring selected gear items",
    Locked = false,
    Callback = function()
        BringGearItems()
    end
})

local BringOthersSettings = {
    OthersItems = {"Red Key", "Blue Key", "Yellow Key", "Grey Key", "Chili Seeds", "Flower Seeds", "Berry Seeds", " FireFly Seeds"},
    OthersToBring = {}
}

function BringOthersItems()
    for _, v in pairs(workspace.Items:GetChildren()) do
        for _, item in ipairs(BringOthersSettings.OthersToBring) do
            if v.Name == item then
                local targetCFrame
                local waitTime = 0.03

                if BringSettings.SelectedBringMethod == "Slow" then
                    waitTime = 0.15
                elseif BringSettings.SelectedBringMethod == "Normal" then
                    waitTime = 0.03
                elseif BringSettings.SelectedBringMethod == "Fast" then
                    waitTime = 0.003
                end

                if BringSettings.SelectedBringPos == "You" then
                    targetCFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Ve)
                elseif BringSettings.SelectedBringPos == "Campfire" then
                    targetCFrame = CFrame.new(0, 20, 0)
                elseif BringSettings.SelectedBringPos == "Crafting Bench" then
                    local benchPart = workspace.Map.Campground.CraftingBench.PrimaryPart or workspace.Map.Campground.CraftingBench:FindFirstChildWhichIsA("BasePart")
                    if benchPart then
                        targetCFrame = benchPart.CFrame + Vector3.new(0, 20, 0)
                    end
                end

                if targetCFrame then
                    pcall(function()
                        Drag(v)
                        wait(waitTime)
                        local vPart = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                        if vPart then
                            vPart.CFrame = targetCFrame
                        end
                        wait(waitTime)
                        Undrag(v)
                    end)
                end
            end
        end
    end
end

Tabs.br:Section({ 
    Title = "Others Items",
})

Tabs.br:Dropdown({
    Title = "Select Others",
    Desc = "Choose other items to bring",
    Values = BringOthersSettings.OthersItems,
    Value = BringOthersSettings.OthersToBring,
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        BringOthersSettings.OthersToBring = option
    end
})

Tabs.br:Button({
    Title = "Bring Other Items",
    Desc = "Bring selected other items",
    Locked = false,
    Callback = function()
        BringOthersItems()
    end
})

local BringMobSettings = {
    cultistItems = {
        "Cultist", "Crossbow Cultist", "Cultist Juggernaut", "Bunny", "Wolf", "Alpha Wolf", "Bear", "Snow Bear", "Deer", "Owl"
    },
    MobToBring = {}
}

function BringMob()
    for _, v in pairs(workspace.Characters:GetChildren()) do
        for _, item in ipairs(BringMobSettings.MobToBring) do
            if v.Name == item then
                local targetCFrame
                local waitTime = 0.03

                if BringSettings.SelectedBringMethod == "Slow" then
                    waitTime = 0.15
                elseif BringSettings.SelectedBringMethod == "Normal" then
                    waitTime = 0.03
                elseif BringSettings.SelectedBringMethod == "Fast" then
                    waitTime = 0.003
                end

                if BringSettings.SelectedBringPos == "You" then
                    targetCFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Ve)
                elseif BringSettings.SelectedBringPos == "Campfire" then
                    targetCFrame = CFrame.new(0, 20, 0)
                elseif BringSettings.SelectedBringPos == "Crafting Bench" then
                    local benchPart = workspace.Map.Campground.CraftingBench.PrimaryPart or workspace.Map.Campground.CraftingBench:FindFirstChildWhichIsA("BasePart")
                    if benchPart then
                        targetCFrame = benchPart.CFrame + Vector3.new(0, 20, 0)
                    end
                end

                if targetCFrame then
                    pcall(function()
                        Drag(v)
                        wait(waitTime)
                        local vPart = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                        if vPart then
                            vPart.CFrame = targetCFrame
                        end
                        wait(waitTime)
                        Undrag(v)
                    end)
                end
            end
        end
    end
end

Tabs.br:Section({ 
    Title = "Mobs",
})

Tabs.br:Dropdown({
    Title = "Select Mob",
    Desc = "Choose mobs to bring",
    Values = BringMobSettings.cultistItems,
    Value = BringMobSettings.MobToBring,
    Multi = true,
    AllowNone = true,
    Callback = function(option)
        BringMobSettings.MobToBring = option
    end
})

Tabs.br:Button({
    Title = "Bring Mobs",
    Desc = "Bring selected mobs",
    Locked = false,
    Callback = function()
        BringMob()
    end
})

-- NED

Tabs.br:Section({ Title = "Sapling", Icon = "sprout" })

Tabs.br:Toggle({
    Title = "Bring Saplings",
    Default = false,
    Callback = function(value)
        autoPlantEnabled = value

        if value then
            autoPlantLoop = true
            spawn(function()
                while autoPlantLoop and autoPlantEnabled do
                    bypassBringSystem({"Sapling"}, function() return autoPlantEnabled end)

                    if not autoPlantEnabled then break end

                    local args = {
                        Instance.new("Model", nil)
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("RequestPlantItem"):InvokeServer(unpack(args))

                    local waitTime = 0
                    while waitTime < 3 and autoPlantEnabled and autoPlantLoop do
                        task.wait(0.1)
                        waitTime = waitTime + 0.1
                    end
                end
                autoPlantLoop = false
            end)
        else
            autoPlantLoop = false
        end
    end
})

Tabs.Fly:Section({ Title = "Player", Icon = "user" })

Tabs.Fly:Slider({
    Title = "Hip Height",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 2,
    },
    Callback = function(v)
        _G.HipHeight = v
        if _G.HipHeightOn then
            game.Players.LocalPlayer.Character.Humanoid.HipHeight = v
        end
    end
})

Tabs.Fly:Slider({
    Title = "Fly Speed",
    Value = { Min = 1, Max = 20, Default = 1 },
    Callback = function(value)
        flySpeed = value
        if FLYING then
            task.spawn(function()
                while FLYING do
                    task.wait(0.1)
                    if game:GetService("UserInputService").TouchEnabled then
                        local root = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if root and root:FindFirstChild("BodyVelocity") then
                            local bv = root:FindFirstChild("BodyVelocity")
                            bv.Velocity = bv.Velocity.Unit * (flySpeed * 50)
                        end
                    end
                end
            end)
        end
    end
})

local speed = 16

local function setSpeed(val)
    local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then humanoid.WalkSpeed = val end
end


Tabs.Fly:Slider({
    Title = "Speed",
    Value = { Min = 16, Max = 150, Default = 16 },
    Callback = function(value)
        speed = value
    end
})

Tabs.Fly:Divider()
Tabs.Fly:Toggle({
    Title = "Enable HipHeight",
    Icon = "user",
    Type = "Toggle",
    Default = false,
    Callback = function(PH)
        _G.HipHeightOn = PH
        if PH then
            game.Players.LocalPlayer.Character.Humanoid.HipHeight = _G.HipHeight or 2
        end
    end
})

Tabs.Fly:Toggle({
    Title = "Enable Fly",
    Value = false,
    Callback = function(state)
        flyToggle = state
        if flyToggle then
            if game:GetService("UserInputService").TouchEnabled then
                MobileFly()
            else
                sFLY()
            end
        else
            NOFLY()
            UnMobileFly()
        end
    end
})
Tabs.Fly:Toggle({
    Title = "Enable Speed",
    Value = false,
    Callback = function(state)
        setSpeed(state and speed or 16)
    end
})
Tabs.Fly:Section({ Title = "Misc", Icon = "flame" })

local RunService = game:GetService("RunService")
local noclipConnection

Tabs.Fly:Toggle({
    Title = "No Clip",
    Value = false,
    Callback = function(state)
        if state then
            noclipConnection = RunService.Stepped:Connect(function()
                local char = Players.LocalPlayer.Character
                if char then
                    for _, part in ipairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
        end
    end
})

local UserInputService = game:GetService("UserInputService")
local infJumpConnection

Tabs.Fly:Toggle({
    Title = "Inf Jump",
    Value = false,
    Callback = function(state)
        if state then
            infJumpConnection = UserInputService.JumpRequest:Connect(function()
                local char = Players.LocalPlayer.Character
                local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end)
        else
            if infJumpConnection then
                infJumpConnection:Disconnect()
                infJumpConnection = nil
            end
        end
    end
})

function createESPText(part, text, color)
    if part:FindFirstChild("ESPTexto") then return end

    local esp = Instance.new("BillboardGui")
    esp.Name = "ESPTexto"
    esp.Adornee = part
    esp.Size = UDim2.new(0, 100, 0, 20)
    esp.StudsOffset = Vector3.new(0, 2.5, 0)
    esp.AlwaysOnTop = true
    esp.MaxDistance = 300

    local label = Instance.new("TextLabel")
    label.Parent = esp
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = color or Color3.fromRGB(255,255,0)
    label.TextStrokeTransparency = 0.2
    label.TextScaled = true
    label.Font = Enum.Font.Code

    esp.Parent = part
end

local function Aesp(nome, tipo)
    local container
    local color
    if tipo == "item" then
        container = workspace:FindFirstChild("Items")
        color = Color3.fromRGB(0, 255, 0)
    elseif tipo == "mob" then
        container = workspace:FindFirstChild("Characters")
        color = Color3.fromRGB(255, 255, 0)
    else
        return
    end
    if not container then return end

    for _, obj in ipairs(container:GetChildren()) do
        if obj.Name == nome then
            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                createESPText(part, obj.Name, color)
            end
        end
    end
end

local function Desp(nome, tipo)
    local container
    if tipo == "item" then
        container = workspace:FindFirstChild("Items")
    elseif tipo == "mob" then
        container = workspace:FindFirstChild("Characters")
    else
        return
    end
    if not container then return end

    for _, obj in ipairs(container:GetChildren()) do
        if obj.Name == nome then
            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                for _, gui in ipairs(part:GetChildren()) do
                    if gui:IsA("BillboardGui") and gui.Name == "ESPTexto" then
                        gui:Destroy()
                    end
                end
            end
        end
    end
end

local selectedItems = {}
local selectedMobs = {}
local espItemsEnabled = false
local espMobsEnabled = false
local espConnections = {}

Tabs.esp:Toggle({
    Title = "Esp Players",
    Icon = "eye",
    Callback = function(enable)
        _G.EspPlayerOn = enable
        if enable then
            pcall(function()
                createPlayerNameBillboard(player)
                end)
                else
                    _G.EspPlayerOn = false
        end
   end
})

local Tree = workspace.Map.Landmarks
local EspTextSize = 16

local function createTreeESP(tree)
    local oldGui = tree:FindFirstChild("TreeHealth")
    if oldGui then oldGui:Destroy() end

    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "TreeHealth"
    billboardGui.Size = UDim2.new(4, 0, 2, 0) 
    billboardGui.StudsOffset = Vector3.new(0, 3, 0) 
    billboardGui.AlwaysOnTop = true
    billboardGui.Parent = tree
   
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)  
    textLabel.BackgroundTransparency = 1
    textLabel.Font = Enum.Font.Code
    textLabel.TextSize = EspTextSize
    textLabel.TextColor3 = Color3.fromRGB(0, 255, 0)  
    textLabel.TextStrokeTransparency = 0.5  
    textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)  
    textLabel.Parent = billboardGui

    local function updateHealth(health)
        if not health then
            textLabel.Text = "??"
            textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            return
        end
        textLabel.Text = tostring(math.floor(health))
        if health < 30 then
            textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
        elseif health < 60 then
            textLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
        else
            textLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
        end
    end

    if tree:IsA("BasePart") then
        updateHealth(tree:GetAttribute("Health"))
        tree:GetAttributeChangedSignal("Health"):Connect(function()
            updateHealth(tree:GetAttribute("Health"))
        end)
    elseif tree:IsA("Model") then
        local humanoid = tree:FindFirstChildOfClass("Humanoid")
        if humanoid then
            updateHealth(humanoid.Health)
            humanoid.HealthChanged:Connect(updateHealth)
        else
            updateHealth(tree:GetAttribute("Health"))
            tree:GetAttributeChangedSignal("Health"):Connect(function()
                updateHealth(tree:GetAttribute("Health"))
            end)
        end
    end
end

local function enableTreeESP()
    for _, tree in pairs(Tree:GetChildren()) do
        if tree.Name == "Small Tree" then
            createTreeESP(tree)
        end
    end
    
    treeAddedConnection = Tree.ChildAdded:Connect(function(tree)
        if tree.Name == "Small Tree" then
            createTreeESP(tree)
        end
    end)
end

local function disableTreeESP()
    for _, tree in pairs(Tree:GetChildren()) do
        local oldGui = tree:FindFirstChild("TreeHealth")
        if oldGui then
            oldGui:Destroy()
        end
    end

    if treeAddedConnection then
        treeAddedConnection:Disconnect()
        treeAddedConnection = nil
    end
end

local treeAddedConnection

Tabs.esp:Toggle({
    Title = "Esp Tree Healths",
    Icon = "eye",
    Callback = function(enable)
        if enable then
            enableTreeESP()
        else
            disableTreeESP()
        end
    end
})

Tabs.esp:Section({ Title = "Esp Items", Icon = "package" })

Tabs.esp:Dropdown({
    Title = "Esp Items",
    Values = ie,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        selectedItems = options
        if espItemsEnabled then
            for _, name in ipairs(ie) do
                if table.find(selectedItems, name) then
                    Aesp(name, "item")
                else
                    Desp(name, "item")
                end
            end
        else
            for _, name in ipairs(ie) do
                Desp(name, "item")
            end
        end
    end
})

Tabs.esp:Toggle({
    Title = "Enable Esp",
    Value = false,
    Callback = function(state)
        espItemsEnabled = state
        for _, name in ipairs(ie) do
            if state and table.find(selectedItems, name) then
                Aesp(name, "item")
            else
                Desp(name, "item")
            end
        end

        if state then
            if not espConnections["Items"] then
                local container = workspace:FindFirstChild("Items")
                if container then
                    espConnections["Items"] = container.ChildAdded:Connect(function(obj)
                        if table.find(selectedItems, obj.Name) then
                            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
                            if part then
                                createESP(part, obj.Name, Color3.fromRGB(0, 255, 0))
                            end
                        end
                    end)
                end
            end
        else
            if espConnections["Items"] then
                espConnections["Items"]:Disconnect()
                espConnections["Items"] = nil
            end
        end
    end
})

Tabs.esp:Section({ Title = "Esp Entity", Icon = "user" })

Tabs.esp:Dropdown({
    Title = "Esp Entity",
    Values = me,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        selectedMobs = options
        if espMobsEnabled then
            for _, name in ipairs(me) do
                if table.find(selectedMobs, name) then
                    Aesp(name, "mob")
                else
                    Desp(name, "mob")
                end
            end
        else
            for _, name in ipairs(me) do
                Desp(name, "mob")
            end
        end
    end
})

Tabs.esp:Toggle({
    Title = "Enable Esp",
    Value = false,
    Callback = function(state)
        espMobsEnabled = state
        for _, name in ipairs(me) do
            if state and table.find(selectedMobs, name) then
                Aesp(name, "mob")
            else
                Desp(name, "mob")
            end
        end

        if state then
            if not espConnections["Mobs"] then
                local container = workspace:FindFirstChild("Characters")
                if container then
                    espConnections["Mobs"] = container.ChildAdded:Connect(function(obj)
                        if table.find(selectedMobs, obj.Name) then
                            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
                            if part then
                                createESP(part, obj.Name, Color3.fromRGB(255, 255, 0))
                            end
                        end
                    end)
                end
            end
        else
            if espConnections["Mobs"] then
                espConnections["Mobs"]:Disconnect()
                espConnections["Mobs"] = nil
            end
        end
    end
})

Tabs.Misc:Section({ Title = "Miscellaneous", Icon = "settings" })

local instantInteractEnabled = false
local instantInteractConnection
local originalHoldDurations = {}

Tabs.Misc:Toggle({
    Title = "Instant Interact",
    Value = false,
    Callback = function(state)
        instantInteractEnabled = state

        if state then
            originalHoldDurations = {}
            instantInteractConnection = task.spawn(function()
                while instantInteractEnabled do
                    for _, obj in ipairs(workspace:GetDescendants()) do
                        if obj:IsA("ProximityPrompt") then
                            if originalHoldDurations[obj] == nil then
                                originalHoldDurations[obj] = obj.HoldDuration
                            end
                            obj.HoldDuration = 0
                        end
                    end
                    task.wait(5)
                end
            end)
        else
            if instantInteractConnection then
                instantInteractEnabled = false
            end
            for obj, value in pairs(originalHoldDurations) do
                if obj and obj:IsA("ProximityPrompt") then
                    obj.HoldDuration = value
                end
            end
            originalHoldDurations = {}
        end
    end
})

Tabs.Misc:Toggle({
    Title = "Auto Collect All Coin Stacks",
    Desc = "Automatically collects all Coin Stacks",
    Default = false,
    Callback = function(value)
        if value then
            _G.AutoCollectCoins = true
            coroutine.wrap(function()
                while _G.AutoCollectCoins do
                    for _, item in pairs(workspace.Items:GetChildren()) do
                        if item.Name == "Coin Stack" and item:FindFirstChild("HumanoidRootPart") then
                            local args = {item}
                            game:GetService("ReplicatedStorage").RemoteEvents.RequestCollectCoints:InvokeServer(unpack(args))
                            warn("Collected a Coin Stack")
                        end
                    end
                    task.wait(0.2)
                end
            end)()
        else
            _G.AutoCollectCoins = false
        end
    end
})

Tabs.Misc:Toggle({
    Title = "Auto Build Anvil",
    Desc = "Puts anvil front back and base together",
    Value = false,
    Callback = function(state)
        autoBuildAnvil = state
        task.spawn(function()
            while autoBuildAnvil do
                for _, partName in ipairs({"Anvil Base", "Anvil Front", "Anvil Back"}) do
                    if workspace:WaitForChild("Items"):FindFirstChild(partName) then
                        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("RequestBuildAnvilPiece"):InvokeServer(
                            workspace:WaitForChild("Map"):WaitForChild("Landmarks"):WaitForChild("ToolWorkshop_MeteorShower"),
                            workspace:WaitForChild("Items")[partName]
                        )
                    end
                end
            end
        end)
    end
})

Tabs.Misc:Section({ Title = "Antis", Icon = "skull" })

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local torchLoop = nil

Tabs.Misc:Toggle({
    Title = "Auto Stun Deer",
    Desc = "Need Flashlight",
    Value = false,
    Callback = function(state)
        if state then
            torchLoop = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local remote = ReplicatedStorage:FindFirstChild("RemoteEvents")
                        and ReplicatedStorage.RemoteEvents:FindFirstChild("DeerHitByTorch")
                    local deer = workspace:FindFirstChild("Characters")
                        and workspace.Characters:FindFirstChild("Deer")
                    if remote and deer then
                        remote:InvokeServer(deer)
                    end
                end)
                task.wait(0.1)
            end)
        else
            if torchLoop then
                torchLoop:Disconnect()
                torchLoop = nil
            end
        end
    end
})

local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")

local ESCAPE_DISTANCE_OWL = 80
local ESCAPE_SPEED_OWL = 5

local ESCAPE_DISTANCE_DEER = 60
local ESCAPE_SPEED_DEER = 4

local ESCAPE_DISTANCE_RAM = 65
local ESCAPE_SPEED_RAM = 4.5

local escapeLoopOwl
local escapeLoopDeer
local escapeLoopRam

Tabs.Misc:Divider()

Tabs.Misc:Toggle({
    Title = "Auto Escape From Owl", 
    Value = false,
    Callback = function(state)
        if state then
            escapeLoopOwl = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local owl = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild("Owl")
                    if owl and owl:FindFirstChild("HumanoidRootPart") then
                        local myPos = HumanoidRootPart.Position
                        local owlPos = owl.HumanoidRootPart.Position
                        local distance = (myPos - owlPos).Magnitude

                        if distance < ESCAPE_DISTANCE_OWL then
                            local direction = (myPos - owlPos).Unit
                            HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + direction * ESCAPE_SPEED_OWL
                        end
                    end
                end)
            end)
        else
            if escapeLoopOwl then
                escapeLoopOwl:Disconnect()
                escapeLoopOwl = nil
            end
        end
    end
})

Tabs.Misc:Toggle({
    Title = "Auto Escape From Deer", 
    Value = false,
    Callback = function(state)
        if state then
            escapeLoopDeer = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local deer = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild("Deer")
                    if deer and deer:FindFirstChild("HumanoidRootPart") then
                        local myPos = HumanoidRootPart.Position
                        local deerPos = deer.HumanoidRootPart.Position
                        local distance = (myPos - deerPos).Magnitude

                        if distance < ESCAPE_DISTANCE_DEER then
                            local direction = (myPos - deerPos).Unit
                            HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + direction * ESCAPE_SPEED_DEER
                        end
                    end
                end)
            end)
        else
            if escapeLoopDeer then
                escapeLoopDeer:Disconnect()
                escapeLoopDeer = nil
            end
        end
    end
})

Tabs.Misc:Toggle({
    Title = "Auto Escape From Ram", 
    Value = false,
    Callback = function(state)
        if state then
            escapeLoopRam = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local ram = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild("Ram")
                    if ram and ram:FindFirstChild("HumanoidRootPart") then
                        local myPos = HumanoidRootPart.Position
                        local ramPos = ram.HumanoidRootPart.Position
                        local distance = (myPos - ramPos).Magnitude

                        if distance < ESCAPE_DISTANCE_RAM then
                            local direction = (myPos - ramPos).Unit
                            HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + direction * ESCAPE_SPEED_RAM
                        end
                    end
                end)
            end)
        else
            if escapeLoopRam then
                escapeLoopRam:Disconnect()
                escapeLoopRam = nil
            end
        end
    end
})

Tabs.Fun:Section({ Title = "Fun", Icon = "star" })

deleteSettings = {
    Owl = false,
    Deer = false,
    Ram = false
}

function autoDelete()
    for name, enabled in pairs(deleteSettings) do
        if enabled then
            for _, obj in pairs(workspace.Characters:GetChildren()) do
                if obj.Name == name then
                    obj:Destroy()
                end
            end
        end
    end
end

RunService.Heartbeat:Connect(autoDelete)

Tabs.Fun:Toggle({
    Title = "Auto Delete Owl",
    Default = false,
    Callback = function(state) 
        deleteSettings.Owl = state
    end
})

Tabs.Fun:Toggle({
    Title = "Auto Delete Deer",
    Default = false,
    Callback = function(state) 
        deleteSettings.Deer = state
    end
})

Tabs.Fun:Toggle({
    Title = "Auto Delete Ram",
    Default = false,
    Callback = function(state) 
        deleteSettings.Ram = state
    end
})

Tabs.Fun:Slider({
    Title = "Game Gravity",
    Desc = "Nothing much cuz game has jump height limit",
    Step = 1,
    Value = {
        Min = 0,
        Max = 500,
        Default = 196,
    },
    Callback = function(value)
        workspace.Gravity = value
        print("Gravity set to:", value)
    end
})

_G.GodModeEnabled = false

function _G.ApplyGodMode(state)
    if character then
        for i, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = not state
            end
        end

        hum = character:FindFirstChildOfClass("Humanoid")
        if state and hum then
            if _G.GodModeHumConnection then _G.GodModeHumConnection:Disconnect() _G.GodModeHumConnection = nil end
            if _G.GodModeHeartbeat then _G.GodModeHeartbeat:Disconnect() _G.GodModeHeartbeat = nil end

            _G.GodModeHumConnection = hum.HealthChanged:Connect(function(hp)
                if _G.GodModeEnabled and hum and hum.Health < hum.MaxHealth then
                    hum.Health = hum.MaxHealth
                end
            end)

            _G.GodModeHeartbeat = game:GetService("RunService").Heartbeat:Connect(function()
                if _G.GodModeEnabled and hum and hum.Health < hum.MaxHealth then
                    hum.Health = hum.MaxHealth
                end
            end)
        else
            if _G.GodModeHumConnection then _G.GodModeHumConnection:Disconnect() _G.GodModeHumConnection = nil end
            if _G.GodModeHeartbeat then _G.GodModeHeartbeat:Disconnect() _G.GodModeHeartbeat = nil end
        end
    end
end

player.CharacterAdded:Connect(function(char)
    character = char
    wait(0.1)
    if _G.GodModeEnabled then
        _G.ApplyGodMode(true)
    end
end)

Tabs.Fun:Toggle({
    Title = "No health bar",
    Desc = "You cant see your health",
    Default = false,
    Callback = function(state)
        _G.GodModeEnabled = state
        _G.ApplyGodMode(state)
        if state then
            print("You cant see your health anymore lol")
        else
            print("Disable health OFF")
        end
    end
})

Tabs.Fun:Toggle({
    Title = "GOD Mode",
    Desc = "Immune to physical and hunger damage",
    Default = false,
    Callback = function(value)
        if value then
            _G.GodModeToggle = true
            spawn(function()
                while _G.GodModeToggle do
                    local dmgEvent = rs:FindFirstChild("RemoteEvents") and rs.RemoteEvents:FindFirstChild("DamagePlayer")
                    if dmgEvent then
                        dmgEvent:FireServer(-9999)
                    else
                        warn("God Mode failed, rejoin game and try again")
                    end
                    RunService.Stepped:Wait()
                end
            end)
        else
            _G.GodModeToggle = false
        end
    end
})

Tabs.Fun:Button({
    Title = "Auto Days Farm GUI",
    Color = Color3.fromHex("#89cff0"),
    Desc = "Just afk and the script will do everything",
    Callback = function()
        loadstring(game:HttpGet("https://paste.rs/hAks7",true))()
    end
})

Tabs.Vision:Section({ Title = "Environment", Icon = "eye" })

local originalParents = {
    Sky = nil,
    Bloom = nil,
    CampfireEffect = nil
}

local function storeOriginalParents()
    local Lighting = game:GetService("Lighting")
    
    local sky = Lighting:FindFirstChild("Sky")
    local bloom = Lighting:FindFirstChild("Bloom")
    local campfireEffect = Lighting:FindFirstChild("CampfireEffect")
    
    if sky and not originalParents.Sky then
        originalParents.Sky = sky.Parent
    end
    if bloom and not originalParents.Bloom then
        originalParents.Bloom = bloom.Parent
    end
    if campfireEffect and not originalParents.CampfireEffect then
        originalParents.CampfireEffect = campfireEffect.Parent
    end
end

storeOriginalParents()

local originalColorCorrectionParent = nil

local function storeColorCorrectionParent()
    local Lighting = game:GetService("Lighting")
    local colorCorrection = Lighting:FindFirstChild("ColorCorrection")
    
    if colorCorrection and not originalColorCorrectionParent then
        originalColorCorrectionParent = colorCorrection.Parent
    end
end

storeColorCorrectionParent()

Tabs.Vision:Toggle({
    Title = "Disable Fog",
    Desc = "",
    Value = false,
    Callback = function(state)
        local Lighting = game:GetService("Lighting")
        
        if state then
            local sky = Lighting:FindFirstChild("Sky")
            local bloom = Lighting:FindFirstChild("Bloom")
            local campfireEffect = Lighting:FindFirstChild("CampfireEffect")
            
            if sky then
                sky.Parent = nil
            end
            if bloom then
                bloom.Parent = nil
            end
            if campfireEffect then
                campfireEffect.Parent = nil
            end
            

        else
            local sky = game:FindFirstChild("Sky", true)
            local bloom = game:FindFirstChild("Bloom", true) 
            local campfireEffect = game:FindFirstChild("CampfireEffect", true)
            
            if not sky then sky = Lighting:FindFirstChild("Sky") end
            if not bloom then bloom = Lighting:FindFirstChild("Bloom") end
            if not campfireEffect then campfireEffect = Lighting:FindFirstChild("CampfireEffect") end
            
            if sky then
                sky.Parent = originalParents.Sky or Lighting
            end
            if bloom then
                bloom.Parent = originalParents.Bloom or Lighting
            end
            if campfireEffect then
                campfireEffect.Parent = originalParents.CampfireEffect or Lighting
            end
            

        end
    end
})

local originalLightingValues = {
    Brightness = nil,
    Ambient = nil,
    OutdoorAmbient = nil,
    ShadowSoftness = nil,
    GlobalShadows = nil,
    Technology = nil
}

local function storeOriginalLighting()
    local Lighting = game:GetService("Lighting")
    
    if not originalLightingValues.Brightness then
        originalLightingValues.Brightness = Lighting.Brightness
        originalLightingValues.Ambient = Lighting.Ambient
        originalLightingValues.OutdoorAmbient = Lighting.OutdoorAmbient
        originalLightingValues.ShadowSoftness = Lighting.ShadowSoftness
        originalLightingValues.GlobalShadows = Lighting.GlobalShadows
        originalLightingValues.Technology = Lighting.Technology
    end
end

storeOriginalLighting()

Tabs.Vision:Toggle({
    Title = "Disable NightCampFire Effect",
    Desc = "",
    Value = false,
    Callback = function(state)
        local Lighting = game:GetService("Lighting")
        
        if state then
            local colorCorrection = Lighting:FindFirstChild("ColorCorrection")
            
            if colorCorrection then
                if not originalColorCorrectionParent then
                    originalColorCorrectionParent = colorCorrection.Parent
                end
                colorCorrection.Parent = nil
            end
        else
            local colorCorrection = nil
            
            colorCorrection = Lighting:FindFirstChild("ColorCorrection")
            
            if not colorCorrection then
                colorCorrection = game:FindFirstChild("ColorCorrection", true)
            end
            
            if colorCorrection then
                colorCorrection.Parent = Lighting
            end
        end
    end
})

Tabs.Vision:Toggle({
    Title = "Full Bright",
    Desc = "",
    Value = false,
    Callback = function(state)
        if state then
            Lighting.ClockTime = 14
            Lighting.Brightness = 2.2
            Lighting.Ambient = Color3.new(1, 1, 1)
            Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
            Lighting.ShadowSoftness = 0
            Lighting.GlobalShadows = false
            Lighting.Technology = Enum.Technology.Compatibility
        else
            Lighting.Brightness = originalLightingValues.Brightness
            Lighting.Ambient = originalLightingValues.Ambient
            Lighting.OutdoorAmbient = originalLightingValues.OutdoorAmbient
            Lighting.ShadowSoftness = originalLightingValues.ShadowSoftness
            Lighting.GlobalShadows = originalLightingValues.GlobalShadows
            Lighting.Technology = originalLightingValues.Technology
        end
    end
})


local NoFogToggle = false
local OriginalFogStart = Lighting.FogStart
local OriginalFogEnd = Lighting.FogEnd

Tabs.Vision:Toggle({
    Title = "No Fog",
    Desc = "",
    Value = false,
    Callback = function(state)
        NoFogToggle = state
        
        if not state then
            Lighting.ClockTime = 14
            Lighting.GlobalShadows = false
            Lighting.FogStart = OriginalFogStart
            Lighting.FogEnd = OriginalFogEnd
        end
    end
})

RunService.Heartbeat:Connect(function()
    if NoFogToggle then
        if Lighting.FogStart ~= 100000 or Lighting.FogEnd ~= 100000 then
            Lighting.ClockTime = 14
            Lighting.GlobalShadows = false
            Lighting.FogStart = 100000
            Lighting.FogEnd = 100000
            print("[] hi 3")
        end
    end
end)

if not vibrantEffect then
    Lighting.ClockTime = 14
    Lighting.GlobalShadows = false
    vibrantEffect = Instance.new("ColorCorrectionEffect")
    vibrantEffect.Name = "VibrantEffect"
    vibrantEffect.Saturation = 0.5
    vibrantEffect.Contrast = 0.2
    vibrantEffect.Brightness = 0.1
    vibrantEffect.Enabled = false 
    vibrantEffect.Parent = Lighting
end

Tabs.Vision:Toggle({
    Title = "Vibrant Colors",
    Value = false,
    Callback = function(state)
        if state then
            Lighting.ClockTime = 14
            Lighting.GlobalShadows = false
            Lighting.Ambient = Color3.fromRGB(180, 180, 180)
            Lighting.OutdoorAmbient = Color3.fromRGB(170, 170, 170)
            Lighting.ColorShift_Top = Color3.fromRGB(255, 230, 200)
            Lighting.ColorShift_Bottom = Color3.fromRGB(200, 240, 255)
            if effect then
                effect.Enabled = true
            end
        else
            if effect then
                effect.Enabled = false
            end
            Lighting.ClockTime = 14
            Lighting.GlobalShadows = false
            Lighting.Ambient = Color3.new(0, 0, 0)
            Lighting.OutdoorAmbient = Color3.new(0, 0, 0)
            Lighting.ColorShift_Top = Color3.new(0, 0, 0)
            Lighting.ColorShift_Bottom = Color3.new(0, 0, 0)
        end
    end
})
Tabs.Vision:Button({
    Title = "Remove Gameplay Paused Gui",
    Desc = "this will remove that annoying gameplay paused thing when you have bad internet",
    Locked = false,
    Callback = function()
        game:GetService("CoreGui").RobloxGui["CoreScripts/NetworkPause"]:Destroy()
    end
})

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    
    if input.KeyCode == Enum.KeyCode.V then
        showPlayers = not showPlayers
        playersText.Visible = showPlayers
    end
end)
